// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__call_policies.pypp.hpp"

#include "__convenience.pypp.hpp"

#include "__array_1.pypp.hpp"

#include "opencv_extra.hpp"

#include "ndarray.hpp"

#include "boost/python/object.hpp"

#include "boost/python/tuple.hpp"

#include "with_ownershiplevel_postcall.hpp"

#include "boost/python/str.hpp"

#include "boost/python/extract.hpp"

#include "__ctypes_integration.pypp.hpp"

#include "opencv_headers.hpp"

#include "pyopencvext/AutotunedIndexParams.pypp.hpp"

#include "pyopencvext/CascadeClassifier.pypp.hpp"

#include "pyopencvext/Complexd.pypp.hpp"

#include "pyopencvext/Complexf.pypp.hpp"

#include "pyopencvext/CompositeIndexParams.pypp.hpp"

#include "pyopencvext/CvANN_MLP.pypp.hpp"

#include "pyopencvext/CvANN_MLP_TrainParams.pypp.hpp"

#include "pyopencvext/CvAdaptiveSkinDetector.pypp.hpp"

#include "pyopencvext/CvAttrList.pypp.hpp"

#include "pyopencvext/CvAvgComp.pypp.hpp"

#include "pyopencvext/CvBoost.pypp.hpp"

#include "pyopencvext/CvBoostParams.pypp.hpp"

#include "pyopencvext/CvBoostTree.pypp.hpp"

#include "pyopencvext/CvCamShiftTracker.pypp.hpp"

#include "pyopencvext/CvChain.pypp.hpp"

#include "pyopencvext/CvChainPtReader.pypp.hpp"

#include "pyopencvext/CvConDensation.pypp.hpp"

#include "pyopencvext/CvConnectedComp.pypp.hpp"

#include "pyopencvext/CvContour.pypp.hpp"

#include "pyopencvext/CvContourScanner.pypp.hpp"

#include "pyopencvext/CvContourTree.pypp.hpp"

#include "pyopencvext/CvConvexityDefect.pypp.hpp"

#include "pyopencvext/CvDTree.pypp.hpp"

#include "pyopencvext/CvDTreeParams.pypp.hpp"

#include "pyopencvext/CvDTreeSplit.pypp.hpp"

#include "pyopencvext/CvDTreeTrainData.pypp.hpp"

#include "pyopencvext/CvEM.pypp.hpp"

#include "pyopencvext/CvEMParams.pypp.hpp"

#include "pyopencvext/CvERTrees.pypp.hpp"

#include "pyopencvext/CvFeatureTree.pypp.hpp"

#include "pyopencvext/CvFileNode.pypp.hpp"

#include "pyopencvext/CvFileStorage.pypp.hpp"

#include "pyopencvext/CvForestERTree.pypp.hpp"

#include "pyopencvext/CvForestTree.pypp.hpp"

#include "pyopencvext/CvFuzzyController.pypp.hpp"

#include "pyopencvext/CvFuzzyCurve.pypp.hpp"

#include "pyopencvext/CvFuzzyFunction.pypp.hpp"

#include "pyopencvext/CvFuzzyMeanShiftTracker.pypp.hpp"

#include "pyopencvext/CvFuzzyPoint.pypp.hpp"

#include "pyopencvext/CvFuzzyRule.pypp.hpp"

#include "pyopencvext/CvGenericHash.pypp.hpp"

#include "pyopencvext/CvGraph.pypp.hpp"

#include "pyopencvext/CvGraphEdge.pypp.hpp"

#include "pyopencvext/CvGraphScanner.pypp.hpp"

#include "pyopencvext/CvGraphVtx.pypp.hpp"

#include "pyopencvext/CvGraphVtx2D.pypp.hpp"

#include "pyopencvext/CvHaarClassifier.pypp.hpp"

#include "pyopencvext/CvHaarClassifierCascade.pypp.hpp"

#include "pyopencvext/CvHaarFeature.pypp.hpp"

#include "pyopencvext/CvHaarStageClassifier.pypp.hpp"

#include "pyopencvext/CvHistogram.pypp.hpp"

#include "pyopencvext/CvKNearest.pypp.hpp"

#include "pyopencvext/CvLSH.pypp.hpp"

#include "pyopencvext/CvLSHOperations.pypp.hpp"

#include "pyopencvext/CvLevMarq.pypp.hpp"

#include "pyopencvext/CvMLData.pypp.hpp"

#include "pyopencvext/CvMSERParams.pypp.hpp"

#include "pyopencvext/CvMemBlock.pypp.hpp"

#include "pyopencvext/CvMemStorage.pypp.hpp"

#include "pyopencvext/CvMemStoragePos.pypp.hpp"

#include "pyopencvext/CvModule.pypp.hpp"

#include "pyopencvext/CvModuleInfo.pypp.hpp"

#include "pyopencvext/CvNArrayIterator.pypp.hpp"

#include "pyopencvext/CvNormalBayesClassifier.pypp.hpp"

#include "pyopencvext/CvPOSITObject.pypp.hpp"

#include "pyopencvext/CvParamGrid.pypp.hpp"

#include "pyopencvext/CvPluginFuncInfo.pypp.hpp"

#include "pyopencvext/CvQuadEdge2D.pypp.hpp"

#include "pyopencvext/CvRTParams.pypp.hpp"

#include "pyopencvext/CvRTrees.pypp.hpp"

#include "pyopencvext/CvSURFParams.pypp.hpp"

#include "pyopencvext/CvSURFPoint.pypp.hpp"

#include "pyopencvext/CvSVM.pypp.hpp"

#include "pyopencvext/CvSVMParams.pypp.hpp"

#include "pyopencvext/CvSeq.pypp.hpp"

#include "pyopencvext/CvSeqBlock.pypp.hpp"

#include "pyopencvext/CvSeqReader.pypp.hpp"

#include "pyopencvext/CvSeqWriter.pypp.hpp"

#include "pyopencvext/CvSet.pypp.hpp"

#include "pyopencvext/CvSetElem.pypp.hpp"

#include "pyopencvext/CvStarDetectorParams.pypp.hpp"

#include "pyopencvext/CvStarKeypoint.pypp.hpp"

#include "pyopencvext/CvStatModel.pypp.hpp"

#include "pyopencvext/CvStereoGCState.pypp.hpp"

#include "pyopencvext/CvString.pypp.hpp"

#include "pyopencvext/CvStringHashNode.pypp.hpp"

#include "pyopencvext/CvSubdiv2D.pypp.hpp"

#include "pyopencvext/CvSubdiv2DPoint.pypp.hpp"

#include "pyopencvext/CvTreeNodeIterator.pypp.hpp"

#include "pyopencvext/CvType.pypp.hpp"

#include "pyopencvext/CvTypeInfo.pypp.hpp"

#include "pyopencvext/CvVectors.pypp.hpp"

#include "pyopencvext/FeatureEvaluator.pypp.hpp"

#include "pyopencvext/FernClassifier.pypp.hpp"

#include "pyopencvext/FileNode.pypp.hpp"

#include "pyopencvext/FileStorage.pypp.hpp"

#include "pyopencvext/FilterEngine.pypp.hpp"

#include "pyopencvext/HOGDescriptor.pypp.hpp"

#include "pyopencvext/Index.pypp.hpp"

#include "pyopencvext/KDTree.pypp.hpp"

#include "pyopencvext/KDTreeIndexParams.pypp.hpp"

#include "pyopencvext/KMeansIndexParams.pypp.hpp"

#include "pyopencvext/KalmanFilter.pypp.hpp"

#include "pyopencvext/KeyPoint.pypp.hpp"

#include "pyopencvext/LDetector.pypp.hpp"

#include "pyopencvext/LevMarqSparse.pypp.hpp"

#include "pyopencvext/LineIterator.pypp.hpp"

#include "pyopencvext/LinearIndexParams.pypp.hpp"

#include "pyopencvext/MSER.pypp.hpp"

#include "pyopencvext/Mat.pypp.hpp"

#include "pyopencvext/MatND.pypp.hpp"

#include "pyopencvext/Mesh3D.pypp.hpp"

#include "pyopencvext/Moments.pypp.hpp"

#include "pyopencvext/NAryMatNDIterator.pypp.hpp"

#include "pyopencvext/Octree.pypp.hpp"

#include "pyopencvext/OneWayDescriptor.pypp.hpp"

#include "pyopencvext/OneWayDescriptorBase.pypp.hpp"

#include "pyopencvext/OneWayDescriptorObject.pypp.hpp"

#include "pyopencvext/PCA.pypp.hpp"

#include "pyopencvext/PatchGenerator.pypp.hpp"

#include "pyopencvext/PlanarObjectDetector.pypp.hpp"

#include "pyopencvext/Point2d.pypp.hpp"

#include "pyopencvext/Point2f.pypp.hpp"

#include "pyopencvext/Point2i.pypp.hpp"

#include "pyopencvext/Point3d.pypp.hpp"

#include "pyopencvext/Point3f.pypp.hpp"

#include "pyopencvext/Point3i.pypp.hpp"

#include "pyopencvext/Ptr_BaseColumnFilter.pypp.hpp"

#include "pyopencvext/Ptr_BaseFilter.pypp.hpp"

#include "pyopencvext/Ptr_BaseRowFilter.pypp.hpp"

#include "pyopencvext/Ptr_CvFileStorage.pypp.hpp"

#include "pyopencvext/Ptr_CvHaarClassifierCascade.pypp.hpp"

#include "pyopencvext/Ptr_CvStereoBMState.pypp.hpp"

#include "pyopencvext/Ptr_FeatureEvaluator.pypp.hpp"

#include "pyopencvext/Ptr_FilterEngine.pypp.hpp"

#include "pyopencvext/RNG.pypp.hpp"

#include "pyopencvext/Range.pypp.hpp"

#include "pyopencvext/Rect.pypp.hpp"

#include "pyopencvext/Rectd.pypp.hpp"

#include "pyopencvext/Rectf.pypp.hpp"

#include "pyopencvext/RotatedRect.pypp.hpp"

#include "pyopencvext/SURF.pypp.hpp"

#include "pyopencvext/SVD.pypp.hpp"

#include "pyopencvext/SavedIndexParams.pypp.hpp"

#include "pyopencvext/Scalar.pypp.hpp"

#include "pyopencvext/SearchParams.pypp.hpp"

#include "pyopencvext/SelfSimDescriptor.pypp.hpp"

#include "pyopencvext/Size2d.pypp.hpp"

#include "pyopencvext/Size2f.pypp.hpp"

#include "pyopencvext/Size2i.pypp.hpp"

#include "pyopencvext/SparseMat.pypp.hpp"

#include "pyopencvext/SparseMatConstIterator.pypp.hpp"

#include "pyopencvext/SparseMatIterator.pypp.hpp"

#include "pyopencvext/SpinImageModel.pypp.hpp"

#include "pyopencvext/StarDetector.pypp.hpp"

#include "pyopencvext/StereoBM.pypp.hpp"

#include "pyopencvext/TermCriteria.pypp.hpp"

#include "pyopencvext/TickMeter.pypp.hpp"

#include "pyopencvext/Vec2b.pypp.hpp"

#include "pyopencvext/Vec2d.pypp.hpp"

#include "pyopencvext/Vec2f.pypp.hpp"

#include "pyopencvext/Vec2i.pypp.hpp"

#include "pyopencvext/Vec2s.pypp.hpp"

#include "pyopencvext/Vec2w.pypp.hpp"

#include "pyopencvext/Vec3b.pypp.hpp"

#include "pyopencvext/Vec3d.pypp.hpp"

#include "pyopencvext/Vec3f.pypp.hpp"

#include "pyopencvext/Vec3i.pypp.hpp"

#include "pyopencvext/Vec3s.pypp.hpp"

#include "pyopencvext/Vec3w.pypp.hpp"

#include "pyopencvext/Vec4b.pypp.hpp"

#include "pyopencvext/Vec4d.pypp.hpp"

#include "pyopencvext/Vec4f.pypp.hpp"

#include "pyopencvext/Vec4i.pypp.hpp"

#include "pyopencvext/Vec4s.pypp.hpp"

#include "pyopencvext/Vec4w.pypp.hpp"

#include "pyopencvext/Vec6d.pypp.hpp"

#include "pyopencvext/Vec6f.pypp.hpp"

#include "pyopencvext/VideoCapture.pypp.hpp"

#include "pyopencvext/VideoWriter.pypp.hpp"

#include "pyopencvext/flann_Index.pypp.hpp"

#include "pyopencvext/lsh_hash.pypp.hpp"

#include "pyopencvext/pyopencvext_enumerations.pypp.hpp"

#include "pyopencvext/pyopencvext_free_functions.pypp.hpp"

#include "pyopencvext/pyopencvext_global_variables.pypp.hpp"

namespace bp = boost::python;

static boost::python::object FAST_23d17220884e2f371691b185394322ec( ::cv::Mat const & image, int threshold, bool nonmax_supression=true ){
    bp::tuple keypoints2;
    std::vector<cv::KeyPoint, std::allocator<cv::KeyPoint> > keypoints3;
    ::cv::FAST(image, keypoints3, threshold, nonmax_supression);
    keypoints2 = convert_vector_to_seq(keypoints3);
    return bp::object( keypoints2 );
}

static boost::python::object HoughCircles_ea2999473356200d9d2fc8b7258555b0( ::cv::Mat const & image, int method, double dp, double minDist, double param1=100, double param2=100, int minRadius=0, int maxRadius=0 ){
    bp::tuple circles2;
    std::vector<cv::Vec<float, 3>, std::allocator<cv::Vec<float, 3> > > circles3;
    ::cv::HoughCircles(image, circles3, method, dp, minDist, param1, param2, minRadius, maxRadius);
    circles2 = convert_vector_to_seq(circles3);
    return bp::object( circles2 );
}

static boost::python::object HoughLines_deaa796a20e753a0b781de4a4d81ba3d( ::cv::Mat const & image, double rho, double theta, int threshold, double srn=0, double stn=0 ){
    bp::tuple lines2;
    std::vector<cv::Vec<float, 2>, std::allocator<cv::Vec<float, 2> > > lines3;
    ::cv::HoughLines(image, lines3, rho, theta, threshold, srn, stn);
    lines2 = convert_vector_to_seq(lines3);
    return bp::object( lines2 );
}

static boost::python::object HoughLinesP_7e83e90590dfee49ad9ee8d704d1cfcb( ::cv::Mat & image, double rho, double theta, int threshold, double minLineLength=0, double maxLineGap=0 ){
    bp::tuple lines2;
    std::vector<cv::Vec<int, 4>, std::allocator<cv::Vec<int, 4> > > lines3;
    ::cv::HoughLinesP(image, lines3, rho, theta, threshold, minLineLength, maxLineGap);
    lines2 = convert_vector_to_seq(lines3);
    return bp::object( lines2 );
}

static boost::python::object HuMoments_646f4ee3824db566d9124eee2bb204ab( ::cv::Moments const & moments ){
    double native_hu[7];
    boost::python::list py_hu;
    ::cv::HuMoments(moments, native_hu);
    pyplus_conv::copy_container( native_hu, native_hu + 7, pyplus_conv::list_inserter( py_hu ) );
    return bp::object( py_hu );
}

static boost::python::object buildPyramid_84cd4ffd24fbd4dbaeccf86ceb1007ac( ::cv::Mat const & src, int maxlevel ){
    bp::tuple dst2;
    std::vector<cv::Mat, std::allocator<cv::Mat> > dst3;
    ::cv::buildPyramid(src, dst3, maxlevel);
    dst2 = convert_vector_to_seq(dst3);
    return bp::object( dst2 );
}

static void calcCovarMatrix_e8cf288956f6478b98045989198e81f5( boost::python::object samples, ::cv::Mat & covar, ::cv::Mat & mean, int flags, int ctype=6 ){
    bool b_samples= samples.ptr() != Py_None;
    int l_samples= b_samples? bp::len(samples): 0;
    std::vector< ::cv::Mat > v_samples(l_samples);
    if(l_samples > 0) for(int i_samples = 0; i_samples < l_samples; ++i_samples) v_samples[i_samples] = bp::extract< ::cv::Mat >(samples[i_samples]);
    
    ::cv::calcCovarMatrix(b_samples? (& (v_samples.front())): 0, l_samples, covar, mean, flags, ctype);
}

static boost::python::tuple calcOpticalFlowPyrLK_2855d31de3545ba96e3fc0ad950740f1( ::cv::Mat const & prevImg, ::cv::Mat const & nextImg, bp::tuple prevPts, ::cv::Size winSize=cv::Size_<int>(15, 15), int maxLevel=3, ::cv::TermCriteria criteria=cv::TermCriteria(3, 30, 1.0000000000000000208166817117216851329430937767e-2), double derivLambda=5.0e-1, int flags=0 ){
    bp::tuple nextPts2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > nextPts3;
    bp::tuple status2;
    std::vector<unsigned char, std::allocator<unsigned char> > status3;
    bp::tuple err2;
    std::vector<float, std::allocator<float> > err3;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > prevPts2;
    convert_seq_to_vector(prevPts, prevPts2);
    ::cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts2, nextPts3, status3, err3, winSize, maxLevel, criteria, derivLambda, flags);
    nextPts2 = convert_vector_to_seq(nextPts3);
    status2 = convert_vector_to_seq(status3);
    err2 = convert_vector_to_seq(err3);
    return bp::make_tuple( nextPts2, status2, err2 );
}

static boost::python::tuple calibrateCamera_e3c243276629b1246626096d8ff70485( bp::tuple objectPoints, bp::tuple imagePoints, ::cv::Size imageSize, ::cv::Mat & cameraMatrix, ::cv::Mat & distCoeffs, int flags=0 ){
    bp::tuple rvecs2;
    std::vector<cv::Mat, std::allocator<cv::Mat> > rvecs3;
    bp::tuple tvecs2;
    std::vector<cv::Mat, std::allocator<cv::Mat> > tvecs3;
    std::vector<std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > >, std::allocator<std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > > > > objectPoints2;
    std::vector<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > >, std::allocator<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > > > imagePoints2;
    convert_seq_to_vector_vector(objectPoints, objectPoints2);
    convert_seq_to_vector_vector(imagePoints, imagePoints2);
    ::cv::calibrateCamera(objectPoints2, imagePoints2, imageSize, cameraMatrix, distCoeffs, rvecs3, tvecs3, flags);
    rvecs2 = convert_vector_to_seq(rvecs3);
    tvecs2 = convert_vector_to_seq(tvecs3);
    return bp::make_tuple( rvecs2, tvecs2 );
}

static boost::python::tuple checkRange_138f1b60b28a059182d9f09088ca2474( ::cv::MatND const & a, bool quiet=true, double minVal=-1.79769313486231570814527423731704356798070567526e+308, double maxVal=1.79769313486231570814527423731704356798070567526e+308 ){
    int idx2;
    bool result = ::cv::checkRange(a, quiet, &idx2, minVal, maxVal);
    return bp::make_tuple( result, idx2 );
}

static boost::python::tuple checkRange_31cc45f75977959e58047954bd730b32( ::cv::Mat const & a, bool quiet=true, double minVal=-1.79769313486231570814527423731704356798070567526e+308, double maxVal=1.79769313486231570814527423731704356798070567526e+308 ){
    cv::Point_<int> pt2;
    bool result = ::cv::checkRange(a, quiet, &pt2, minVal, maxVal);
    return bp::make_tuple( result, pt2 );
}

static boost::python::object computeCorrespondEpilines_c5fa9f4742dac0ce300bb37345eb1f07( ::cv::Mat const & points1, int whichImage, ::cv::Mat const & F ){
    bp::tuple lines2;
    std::vector<cv::Vec<float, 3>, std::allocator<cv::Vec<float, 3> > > lines3;
    ::cv::computeCorrespondEpilines(points1, whichImage, F, lines3);
    lines2 = convert_vector_to_seq(lines3);
    return bp::object( lines2 );
}

static boost::python::object convertPointsHomogeneous_a80a768ed55e897cac15946457cd1696( ::cv::Mat const & src ){
    bp::tuple dst2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > dst3;
    ::cv::convertPointsHomogeneous(src, dst3);
    dst2 = convert_vector_to_seq(dst3);
    return bp::object( dst2 );
}

static boost::python::object convertPointsHomogeneous_d220e3269e8c59fdb5b2dc2f830579b0( ::cv::Mat const & src ){
    bp::tuple dst2;
    std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > > dst3;
    ::cv::convertPointsHomogeneous(src, dst3);
    dst2 = convert_vector_to_seq(dst3);
    return bp::object( dst2 );
}

static boost::python::object convexHull_a7bf196b869588f11c69529c43975a42( ::cv::Mat const & points, bool clockwise=false ){
    bp::tuple hull2;
    std::vector<int, std::allocator<int> > hull3;
    ::cv::convexHull(points, hull3, clockwise);
    hull2 = convert_vector_to_seq(hull3);
    return bp::object( hull2 );
}

static boost::python::object cornerSubPix_897410ee39f221d5b382cc794de38b84( ::cv::Mat const & image, bp::tuple corners, ::cv::Size winSize, ::cv::Size zeroZone, ::cv::TermCriteria criteria ){
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > corners2;
    convert_seq_to_vector(corners, corners2);
    ::cv::cornerSubPix(image, corners2, winSize, zeroZone, criteria);
    corners = convert_vector_to_seq(corners2);
    return bp::object( corners );
}

static void cvAcc_ef7ed9735ac6fce4129e5e89f645482d( ::cv::Mat & image, ::cv::Mat & sum, ::cv::Mat mask=cv::Mat() ){
    ::cvAcc(get_CvMat_ptr(image), get_CvMat_ptr(sum), get_CvMat_ptr(mask));
}

static boost::python::tuple cvCalcAffineFlowPyrLK_3a4b3f5dff85e72a121da3f42cded4aa( ::cv::Mat & prev, ::cv::Mat & curr, ::cv::Mat & prev_pyr, ::cv::Mat & curr_pyr, boost::python::object prev_features, ::CvSize win_size, int level, ::CvTermCriteria criteria, int flags ){
    bool b_prev_features= prev_features.ptr() != Py_None;
    int l_prev_features= b_prev_features? bp::len(prev_features): 0;
    std::vector < char > status2(l_prev_features * 1);
    std::vector < float > track_error2(l_prev_features * 1);
    std::vector < ::CvPoint2D32f > curr_features2(l_prev_features * 1);
    std::vector < float > matrices2(l_prev_features * 1);
    std::vector< ::CvPoint2D32f > v_prev_features(l_prev_features);
    if(l_prev_features > 0) for(int i_prev_features = 0; i_prev_features < l_prev_features; ++i_prev_features) v_prev_features[i_prev_features] = bp::extract< ::CvPoint2D32f >(prev_features[i_prev_features]);
    
    ::cvCalcAffineFlowPyrLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), get_CvMat_ptr(prev_pyr), get_CvMat_ptr(curr_pyr), b_prev_features? (& (v_prev_features.front())): 0, b_prev_features? (& (curr_features2.front())): 0, b_prev_features? (& (matrices2.front())): 0, l_prev_features, win_size, level, b_prev_features? (& (status2.front())): 0, b_prev_features? (& (track_error2.front())): 0, criteria, flags);
    return bp::make_tuple( bp::tuple(status2)
                            , bp::tuple(track_error2)
                            , bp::tuple(curr_features2)
                            , bp::tuple(matrices2) );
}

static void cvCalcArrBackProject_5961923bfd62f49a1a0aa6e73fd2cee6( boost::python::object image, ::cv::Mat & dst, ::CvHistogram const * hist ){
    bool b_image= image.ptr() != Py_None;
    int l_image= b_image? bp::len(image): 0;
    std::vector< void * > v_image(l_image);
    if(l_image > 0) for(int i_image = 0; i_image < l_image; ++i_image) v_image[i_image] = bp::extract< void * >(image[i_image]);
    
    ::cvCalcArrBackProject(b_image? (& (v_image.front())): 0, get_CvMat_ptr(dst), hist);
}

static void cvCalcArrBackProjectPatch_5574debe9c7d943baa020075e0434b56( boost::python::object image, ::cv::Mat & dst, ::CvSize range, ::CvHistogram * hist, int method, double factor ){
    bool b_image= image.ptr() != Py_None;
    int l_image= b_image? bp::len(image): 0;
    std::vector< void * > v_image(l_image);
    if(l_image > 0) for(int i_image = 0; i_image < l_image; ++i_image) v_image[i_image] = bp::extract< void * >(image[i_image]);
    
    ::cvCalcArrBackProjectPatch(b_image? (& (v_image.front())): 0, get_CvMat_ptr(dst), range, hist, method, factor);
}

static void cvCalcArrHist_1919ae68601cfdffd256e40ac0fbe86e( boost::python::object arr, ::CvHistogram * hist, int accumulate=0, ::cv::Mat mask=cv::Mat() ){
    bool b_arr= arr.ptr() != Py_None;
    int l_arr= b_arr? bp::len(arr): 0;
    std::vector< void * > v_arr(l_arr);
    if(l_arr > 0) for(int i_arr = 0; i_arr < l_arr; ++i_arr) v_arr[i_arr] = bp::extract< void * >(arr[i_arr]);
    
    ::cvCalcArrHist(b_arr? (& (v_arr.front())): 0, hist, accumulate, get_CvMat_ptr(mask));
}

static void cvCalcBayesianProb_1195a20f1f016c88866792b21372e3f9( boost::python::object src, boost::python::object dst ){
    bool b_src= src.ptr() != Py_None;
    int l_src= b_src? bp::len(src): 0;
    bool b_dst= dst.ptr() != Py_None;
    int l_dst= b_dst? bp::len(dst): 0;
    std::vector< ::CvHistogram * > v_src(l_src);
    if(l_src > 0) for(int i_src = 0; i_src < l_src; ++i_src) v_src[i_src] = bp::extract< ::CvHistogram * >(src[i_src]);
    
    std::vector< ::CvHistogram * > v_dst(l_dst);
    if(l_dst > 0) for(int i_dst = 0; i_dst < l_dst; ++i_dst) v_dst[i_dst] = bp::extract< ::CvHistogram * >(dst[i_dst]);
    
    ::cvCalcBayesianProb(b_src? (& (v_src.front())): 0, l_src, b_dst? (& (v_dst.front())): 0);
}

static boost::python::object cvCalcEMD2_f4e5308a9258b3a75a06fb112d06a2e8( ::cv::Mat & signature1, ::cv::Mat & signature2, int distance_type, boost::python::object distance_func=bp::object(), ::cv::Mat cost_matrix=cv::Mat(), ::cv::Mat flow=cv::Mat(), float * lower_bound=0, boost::python::object userdata=bp::object() ){
    bool b_distance_func= distance_func.ptr() != Py_None;
    boost::python::tuple z_distance_func;
    if(b_distance_func) z_distance_func = bp::make_tuple(distance_func, userdata);
    float result = ::cvCalcEMD2(get_CvMat_ptr(signature1), get_CvMat_ptr(signature2), distance_type, b_distance_func? sdDistanceFunction: 0, get_CvMat_ptr(cost_matrix), get_CvMat_ptr(flow), lower_bound, b_distance_func? (void *)(z_distance_func.ptr()): 0);
    return bp::object( result );
}

static boost::python::object cvCalcGlobalOrientation_9d75a586d5a67c41e4450ccf9b8af7b3( ::cv::Mat & orientation, ::cv::Mat & mask, ::cv::Mat & mhi, double timestamp, double duration ){
    double result = ::cvCalcGlobalOrientation(get_CvMat_ptr(orientation), get_CvMat_ptr(mask), get_CvMat_ptr(mhi), timestamp, duration);
    return bp::object( result );
}

static void cvCalcHist_419724e5b83c7c4f7e5371b8d787f899( boost::python::object image, ::CvHistogram * hist, int accumulate=0, ::cv::Mat mask=cv::Mat() ){
    bool b_image= image.ptr() != Py_None;
    int l_image= b_image? bp::len(image): 0;
    std::vector< ::_IplImage * > v_image(l_image);
    if(l_image > 0) for(int i_image = 0; i_image < l_image; ++i_image) v_image[i_image] = bp::extract< ::_IplImage * >(image[i_image]);
    
    ::cvCalcHist(b_image? (& (v_image.front())): 0, hist, accumulate, get_CvMat_ptr(mask));
}

static boost::python::object cvCalcImageHomography_a814cf819bbf03a0c8d0b4fd1b700335( boost::python::object line, ::CvPoint3D32f * center, boost::python::object intrinsic ){
    float native_line[3];
    float native_intrinsic[9];
    float native_homography[9];
    boost::python::list py_homography;
    pyplus_conv::ensure_uniform_sequence< float >( line, 3 );
    pyplus_conv::copy_sequence( line, pyplus_conv::array_inserter( native_line, 3 ) );
    pyplus_conv::ensure_uniform_sequence< float >( intrinsic, 9 );
    pyplus_conv::copy_sequence( intrinsic, pyplus_conv::array_inserter( native_intrinsic, 9 ) );
    ::cvCalcImageHomography(native_line, center, native_intrinsic, native_homography);
    pyplus_conv::copy_container( native_homography, native_homography + 9, pyplus_conv::list_inserter( py_homography ) );
    return bp::object( py_homography );
}

static void cvCalcMotionGradient_7506fb6ca34b4a6cb9165f5aff081454( ::cv::Mat & mhi, ::cv::Mat & mask, ::cv::Mat & orientation, double delta1, double delta2, int aperture_size=3 ){
    ::cvCalcMotionGradient(get_CvMat_ptr(mhi), get_CvMat_ptr(mask), get_CvMat_ptr(orientation), delta1, delta2, aperture_size);
}

static void cvCalcOpticalFlowBM_3537c5574d176e4f3dea85450be5ee9f( ::cv::Mat & prev, ::cv::Mat & curr, ::CvSize block_size, ::CvSize shift_size, ::CvSize max_range, int use_previous, ::cv::Mat & velx, ::cv::Mat & vely ){
    ::cvCalcOpticalFlowBM(get_CvMat_ptr(prev), get_CvMat_ptr(curr), block_size, shift_size, max_range, use_previous, get_CvMat_ptr(velx), get_CvMat_ptr(vely));
}

static void cvCalcOpticalFlowHS_0757feb4eeb7fd8c38b710aec2f5f8e9( ::cv::Mat & prev, ::cv::Mat & curr, int use_previous, ::cv::Mat & velx, ::cv::Mat & vely, double lambda, ::CvTermCriteria criteria ){
    ::cvCalcOpticalFlowHS(get_CvMat_ptr(prev), get_CvMat_ptr(curr), use_previous, get_CvMat_ptr(velx), get_CvMat_ptr(vely), lambda, criteria);
}

static void cvCalcOpticalFlowLK_0539268816232dbc93df209c0dc87327( ::cv::Mat & prev, ::cv::Mat & curr, ::CvSize win_size, ::cv::Mat & velx, ::cv::Mat & vely ){
    ::cvCalcOpticalFlowLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), win_size, get_CvMat_ptr(velx), get_CvMat_ptr(vely));
}

static boost::python::tuple cvCalcOpticalFlowPyrLK_925fd4448f97740474886f84b12836c2( ::cv::Mat & prev, ::cv::Mat & curr, ::cv::Mat & prev_pyr, ::cv::Mat & curr_pyr, boost::python::object prev_features, ::CvSize win_size, int level, ::CvTermCriteria criteria, int flags ){
    bool b_prev_features= prev_features.ptr() != Py_None;
    int l_prev_features= b_prev_features? bp::len(prev_features): 0;
    std::vector < char > status2(l_prev_features * 1);
    std::vector < float > track_error2(l_prev_features * 1);
    std::vector < ::CvPoint2D32f > curr_features2(l_prev_features * 1);
    std::vector< ::CvPoint2D32f > v_prev_features(l_prev_features);
    if(l_prev_features > 0) for(int i_prev_features = 0; i_prev_features < l_prev_features; ++i_prev_features) v_prev_features[i_prev_features] = bp::extract< ::CvPoint2D32f >(prev_features[i_prev_features]);
    
    ::cvCalcOpticalFlowPyrLK(get_CvMat_ptr(prev), get_CvMat_ptr(curr), get_CvMat_ptr(prev_pyr), get_CvMat_ptr(curr_pyr), b_prev_features? (& (v_prev_features.front())): 0, b_prev_features? (& (curr_features2.front())): 0, l_prev_features, win_size, level, b_prev_features? (& (status2.front())): 0, b_prev_features? (& (track_error2.front())): 0, criteria, flags);
    return bp::make_tuple( bp::tuple(status2)
                            , bp::tuple(track_error2)
                            , bp::tuple(curr_features2) );
}

static void cvConDensInitSampleSet_2b2c9d04e9f57fb36a248c795590341d( ::CvConDensation * condens, ::cv::Mat & lower_bound, ::cv::Mat & upper_bound ){
    ::cvConDensInitSampleSet(condens, get_CvMat_ptr(lower_bound), get_CvMat_ptr(upper_bound));
}

static void cvConvertImage_9d5028440635df77832885475bf0ea00( ::cv::Mat & src, ::cv::Mat & dst, int flags=0 ){
    ::cvConvertImage(get_CvMat_ptr(src), get_CvMat_ptr(dst), flags);
}

static boost::python::object cvConvexityDefects_cc97bf52cc42e365950605a23b42e95a( ::cv::Mat & contour, ::cv::Mat & convexhull, ::CvMemStorage * storage=0 ){
    ::CvSeq * result = ::cvConvexityDefects(get_CvMat_ptr(contour), get_CvMat_ptr(convexhull), storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::with_custodian_and_ward_postcall< 0, 1, bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static boost::python::object cvCopyHist_b2f53bbcb5a66f34f5710634d38c376f( ::CvHistogram const * src ){
    CvHistogram * dst2=(::CvHistogram *)0;
    ::cvCopyHist(src, &dst2);
    typedef bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvHistogram * >( dst2 ) );
}

static void cvCorrectMatches_055faac2f695cea7fa86e829ba6bdc99( ::cv::Mat & F, ::cv::Mat & points1, ::cv::Mat & points2, ::cv::Mat & new_points1, ::cv::Mat & new_points2 ){
    ::cvCorrectMatches(get_CvMat_ptr(F), get_CvMat_ptr(points1), get_CvMat_ptr(points2), get_CvMat_ptr(new_points1), get_CvMat_ptr(new_points2));
}

static boost::python::object cvCreateHist_f2b39da376344404265809e761a6aaba( boost::python::object sizes, int type, boost::python::object ranges=bp::object(), int uniform=1 ){
    bool b_sizes= sizes.ptr() != Py_None;
    int l_sizes= b_sizes? bp::len(sizes): 0;
    typedef float *LP_ranges;
    bool b_ranges = (ranges.ptr() != Py_None);
    int i_ranges, j_ranges, n0_ranges = b_ranges? bp::len(ranges): 0;
    int *n1_ranges = b_ranges? new int [n0_ranges]: NULL;
    LP_ranges *buf_ranges = b_ranges? new LP_ranges [n0_ranges]: NULL;
    for(i_ranges = 0; i_ranges < n0_ranges; ++i_ranges)
    {
        bp::object const &obj_ranges = ranges[i_ranges];
        n1_ranges[i_ranges] = bp::len(obj_ranges);
        buf_ranges[i_ranges] = new float [n1_ranges[i_ranges]];
        for(j_ranges = 0; j_ranges < n1_ranges[i_ranges]; ++j_ranges)
            buf_ranges[i_ranges][j_ranges] = bp::extract< float > ( obj_ranges[j_ranges] );
    }
        
    std::vector< int > v_sizes(l_sizes);
    if(l_sizes > 0) for(int i_sizes = 0; i_sizes < l_sizes; ++i_sizes) v_sizes[i_sizes] = bp::extract< int >(sizes[i_sizes]);
    
    ::CvHistogram * result = ::cvCreateHist(l_sizes, b_sizes? (& (v_sizes.front())): 0, type, (float * *) buf_ranges, uniform);
    if(b_ranges)
    {
        for(i_ranges = 0; i_ranges < n0_ranges; ++i_ranges) delete[] buf_ranges[i_ranges];
        delete[] n1_ranges;
        delete[] buf_ranges;
    }
        
    typedef bp::with_ownershiplevel_postcall< 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvHistogram * >( result ) );
}

static boost::python::object cvCreateKDTree_bedd697814f42b0adb235e1d1bda9bdd( ::cv::Mat & desc ){
    ::CvFeatureTree * result = ::cvCreateKDTree(get_CvMat_ptr(desc));
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvFeatureTree * >( result ) );
}

static boost::python::object cvCreateSpillTree_22146c3478f3d8c8ff22213a86f1b244( ::cv::Mat & raw_data, int const naive=50, double const rho=6.99999999999999955591079014993738383054733276367e-1, double const tau=1.00000000000000005551115123125782702118158340454e-1 ){
    ::CvFeatureTree * result = ::cvCreateSpillTree(get_CvMat_ptr(raw_data), naive, rho, tau);
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvFeatureTree * >( result ) );
}

static boost::python::tuple cvCreateTrackbar2_c093a5d4e70019414d270b02dacaafb5( char const * trackbar_name, char const * window_name, unsigned int value, int count, boost::python::object on_change, boost::python::object userdata=bp::object() ){
    boost::python::tuple z_on_change= bp::make_tuple(on_change, userdata);
    int result = ::cvCreateTrackbar2(trackbar_name, window_name, reinterpret_cast< int * >( value ), count, sdTrackbarCallback2, (void *)(z_on_change.ptr()));
    return bp::make_tuple( result, z_on_change );
}

static void cvDistTransform_68addecae85b6b48cd46044102a6c028( ::cv::Mat & src, ::cv::Mat & dst, int distance_type=2, int mask_size=3, boost::python::object mask=bp::object(), ::cv::Mat labels=cv::Mat() ){
    bool b_mask= mask.ptr() != Py_None;
    int l_mask= b_mask? bp::len(mask): 0;
    std::vector< float > v_mask(l_mask);
    if(l_mask > 0) for(int i_mask = 0; i_mask < l_mask; ++i_mask) v_mask[i_mask] = bp::extract< float >(mask[i_mask]);
    
    ::cvDistTransform(get_CvMat_ptr(src), get_CvMat_ptr(dst), distance_type, mask_size, b_mask? (& (v_mask.front())): 0, get_CvMat_ptr(labels));
}

static void cvEndWriteStruct_49df8f8a99539026dfbd302575d7a485( ::cv::FileStorage & fs ){
    ::cvEndWriteStruct(fs.fs);
}

static void cvEqualizeHist_02ceca177f2ff14473c32e524cb68017( ::cv::Mat & src, ::cv::Mat & dst ){
    ::cvEqualizeHist(get_CvMat_ptr(src), get_CvMat_ptr(dst));
}

static boost::python::object cvEstimateRigidTransform_2f885814bd847b94c8621a570a36abad( ::cv::Mat & A, ::cv::Mat & B, ::cv::Mat & M, int full_affine ){
    int result = ::cvEstimateRigidTransform(get_CvMat_ptr(A), get_CvMat_ptr(B), get_CvMat_ptr(M), full_affine);
    return bp::object( result );
}

static void cvFindFeatures_3cdcd7c246944a80a295b6f20e448cfc( ::CvFeatureTree * tr, ::cv::Mat & query_points, ::cv::Mat & indices, ::cv::Mat & dist, int k, int emax=20 ){
    ::cvFindFeatures(tr, get_CvMat_ptr(query_points), get_CvMat_ptr(indices), get_CvMat_ptr(dist), k, emax);
}

static boost::python::object cvFindFeaturesBoxed_6d675cd8257b64f665600bd276900d3e( ::CvFeatureTree * tr, ::cv::Mat & bounds_min, ::cv::Mat & bounds_max, ::cv::Mat & out_indices ){
    int result = ::cvFindFeaturesBoxed(tr, get_CvMat_ptr(bounds_min), get_CvMat_ptr(bounds_max), get_CvMat_ptr(out_indices));
    return bp::object( result );
}

static boost::python::object cvFindNearestPoint2D_4658231361f43a6fc66c2e150f75dca8( ::CvSubdiv2D * subdiv, const ::cv::Point2f & pt ){
    ::CvSubdiv2DPoint * result = ::cvFindNearestPoint2D(subdiv, (CvPoint2D32f)(pt));
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2DPoint * >( result ) );
}

static void cvFindStereoCorrespondenceGC_c3eefaed321a780e7059f7c3392c4672( ::cv::Mat & left, ::cv::Mat & right, ::cv::Mat & disparityLeft, ::cv::Mat & disparityRight, ::CvStereoGCState * state, int useDisparityGuess=0 ){
    ::cvFindStereoCorrespondenceGC(get_CvMat_ptr(left), get_CvMat_ptr(right), get_CvMat_ptr(disparityLeft), get_CvMat_ptr(disparityRight), state, useDisparityGuess);
}

static boost::python::object cvGetElemType_28303ccd15acadc45a20b8189b3b5941( ::cv::Mat & arr ){
    int result = ::cvGetElemType(get_CvMat_ptr(arr));
    return bp::object( result );
}

static boost::python::object cvGetFileNode_6a2476df18b42d117da27c3c0b8b7c10( ::cv::FileStorage & fs, ::cv::FileNode & map, ::CvStringHashNode const * key, int create_missing=0 ){
    ::CvFileNode * result = ::cvGetFileNode(fs.fs, *(map), key, create_missing);
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvFileNode * >( result ) );
}

static boost::python::object cvGetFileNodeByName_061e25a343ad5bb2f02da02bf45be998( ::CvFileStorage const * fs, ::cv::FileNode const & map, char const * name ){
    ::CvFileNode * result = ::cvGetFileNodeByName(fs, *(map), name);
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvFileNode * >( result ) );
}

static boost::python::object cvGetFileNodeName_dad254a89ba86caf1ba5012875e2fb32( ::cv::FileNode const & node ){
    char const * result = ::cvGetFileNodeName(*(node));
    return bp::object( result );
}

static boost::python::object cvGetHashedKey_5bf3bb09f908d63c5767d651120f813f( ::cv::FileStorage & fs, char const * name, int len=-0x000000001, int create_missing=0 ){
    ::CvStringHashNode * result = ::cvGetHashedKey(fs.fs, name, len, create_missing);
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvStringHashNode * >( result ) );
}

static void cvGetMinMaxHistValue_a31aae680af640edcfcb77bf873f90f6( ::CvHistogram const * hist, unsigned int min_value, unsigned int max_value, unsigned int min_idx=0, unsigned int max_idx=0 ){
    ::cvGetMinMaxHistValue(hist, reinterpret_cast< float * >( min_value ), reinterpret_cast< float * >( max_value ), reinterpret_cast< int * >( min_idx ), reinterpret_cast< int * >( max_idx ));
}

static void cvGetQuadrangleSubPix_fe2b1a5028fa8b02301dc960cdfbc131( ::cv::Mat & src, ::cv::Mat & dst, ::cv::Mat & map_matrix ){
    ::cvGetQuadrangleSubPix(get_CvMat_ptr(src), get_CvMat_ptr(dst), get_CvMat_ptr(map_matrix));
}

static boost::python::object cvInitNArrayIterator_4c1924434c279d42b088754762acc53b( boost::python::object arrs, ::cv::Mat & mask, ::CvMatND * stubs, ::CvNArrayIterator * array_iterator, int flags=0 ){
    bool b_arrs= arrs.ptr() != Py_None;
    int l_arrs= b_arrs? bp::len(arrs): 0;
    std::vector< void * > v_arrs(l_arrs);
    if(l_arrs > 0) for(int i_arrs = 0; i_arrs < l_arrs; ++i_arrs) v_arrs[i_arrs] = bp::extract< void * >(arrs[i_arrs]);
    
    int result = ::cvInitNArrayIterator(l_arrs, b_arrs? (& (v_arrs.front())): 0, get_CvMat_ptr(mask), stubs, array_iterator, flags);
    return bp::object( result );
}

static boost::python::object cvInitSystem_f0aa383f9ae0b2f0bf89bbcb5e73da23( boost::python::object argv ){
    bool b_argv= argv.ptr() != Py_None;
    int l_argv= b_argv? bp::len(argv): 0;
    std::vector< char * > v_argv(l_argv);
    if(l_argv > 0) for(int i_argv = 0; i_argv < l_argv; ++i_argv) v_argv[i_argv] = bp::extract< char * >(argv[i_argv]);
    
    int result = ::cvInitSystem(l_argv, b_argv? (& (v_argv.front())): 0);
    return bp::object( result );
}

static void cvLSHAdd_fead3e6b36de0b14c88ef1b561c6e621( ::CvLSH * lsh, ::cv::Mat & data, ::cv::Mat indices=cv::Mat() ){
    ::cvLSHAdd(lsh, get_CvMat_ptr(data), get_CvMat_ptr(indices));
}

static void cvLSHQuery_a5f47e360cc9701a6672c12490153852( ::CvLSH * lsh, ::cv::Mat & query_points, ::cv::Mat & indices, ::cv::Mat & dist, int k, int emax ){
    ::cvLSHQuery(lsh, get_CvMat_ptr(query_points), get_CvMat_ptr(indices), get_CvMat_ptr(dist), k, emax);
}

static void cvLSHRemove_5f32fb503216c52038c4ae3bf17b62db( ::CvLSH * lsh, ::cv::Mat & indices ){
    ::cvLSHRemove(lsh, get_CvMat_ptr(indices));
}

static void cvLinearPolar_b75d44697de3c90f0462366e93d77425( ::cv::Mat & src, ::cv::Mat & dst, const ::cv::Point2f & center, double maxRadius, int flags=9 ){
    ::cvLinearPolar(get_CvMat_ptr(src), get_CvMat_ptr(dst), (CvPoint2D32f)(center), maxRadius, flags);
}

static void cvLogPolar_27c4d18226a6e750886777db97773f4d( ::cv::Mat & src, ::cv::Mat & dst, const ::cv::Point2f & center, double M, int flags=9 ){
    ::cvLogPolar(get_CvMat_ptr(src), get_CvMat_ptr(dst), (CvPoint2D32f)(center), M, flags);
}

static void cvMultiplyAcc_c64c83fc39cb1265f3d1a69d9e600a47( ::cv::Mat & image1, ::cv::Mat & image2, ::cv::Mat & acc, ::cv::Mat mask=cv::Mat() ){
    ::cvMultiplyAcc(get_CvMat_ptr(image1), get_CvMat_ptr(image2), get_CvMat_ptr(acc), get_CvMat_ptr(mask));
}

static boost::python::object cvPointSeqFromMat_ef8459cfef37d715411cf088e0da5576( int seq_kind, ::cv::Mat & mat, ::CvContour * contour_header, ::CvSeqBlock * block ){
    ::CvSeq * result = ::cvPointSeqFromMat(seq_kind, get_CvMat_ptr(mat), contour_header, block);
    typedef bp::with_custodian_and_ward_postcall< 0, 2, bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvPyrMeanShiftFiltering_21ec6b7149a6e00a31f1d76aebb9a22b( ::cv::Mat & src, ::cv::Mat & dst, double sp, double sr, int max_level=1, ::CvTermCriteria termcrit=cv::TermCriteria(3, 5, 1.0e+0) ){
    ::cvPyrMeanShiftFiltering(get_CvMat_ptr(src), get_CvMat_ptr(dst), sp, sr, max_level, termcrit);
}

static boost::python::object cvPyrSegmentation_0a5e58f4641f1c9757bb83d3f16f4191( ::cv::Mat & src, ::cv::Mat & dst, ::CvMemStorage * storage, int level, double threshold1, double threshold2 ){
    CvSeq * comp2=(::CvSeq *)0;
    ::cvPyrSegmentation(get_IplImage_ptr(src), get_IplImage_ptr(dst), storage, &comp2, level, threshold1, threshold2);
    typedef bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( comp2 ) );
}

static void cvRandArr_7e6e03c94e3a5f654b62b47647889d1d( ::cv::RNG & rng, ::cv::Mat & arr, int dist_type, ::CvScalar param1, ::CvScalar param2 ){
    ::cvRandArr(&rng.state, get_CvMat_ptr(arr), dist_type, param1, param2);
}

static boost::python::object cvRange_073a997114e2c96bbeff2aaa986e76a1( ::cv::Mat & mat, double start, double end ){
    ::CvArr * result = ::cvRange(get_CvMat_ptr(mat), start, end);
    typedef bp::return_self< > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvArr * >( result ) );
}

static boost::python::object cvReadInt_dca28f92c7fa1c5a899d9ab353ae882e( ::cv::FileNode const & node, int default_value=0 ){
    int result = ::cvReadInt(*(node), default_value);
    return bp::object( result );
}

static boost::python::object cvReadIntByName_7241d5979fbc58c330d0adada9c3a3db( ::CvFileStorage const * fs, ::cv::FileNode const & map, char const * name, int default_value=0 ){
    int result = ::cvReadIntByName(fs, *(map), name, default_value);
    return bp::object( result );
}

static boost::python::object cvReadReal_77fd0854d614bbd71a10b38d8f07166b( ::cv::FileNode const & node, double default_value=0.0 ){
    double result = ::cvReadReal(*(node), default_value);
    return bp::object( result );
}

static boost::python::object cvReadRealByName_28cd8eea8cf4c8740bae8bb907fc7ea4( ::CvFileStorage const * fs, ::cv::FileNode const & map, char const * name, double default_value=0.0 ){
    double result = ::cvReadRealByName(fs, *(map), name, default_value);
    return bp::object( result );
}

static boost::python::object cvReadString_2d9e9aabc6de8c1b6e5e3284f1e79619( ::cv::FileNode const & node, char const * default_value=0 ){
    char const * result = ::cvReadString(*(node), default_value);
    return bp::object( result );
}

static boost::python::object cvReadStringByName_b4debf88a87b4914bb1fcab2b777cee6( ::CvFileStorage const * fs, ::cv::FileNode const & map, char const * name, char const * default_value=0 ){
    char const * result = ::cvReadStringByName(fs, *(map), name, default_value);
    return bp::object( result );
}

static void cvReleaseConDensation_f998e5f5422410bd74b2ba960fd05e2c( ::CvConDensation condens ){
    CvConDensation * tmp_condens = reinterpret_cast< CvConDensation * >(& condens);
    ::cvReleaseConDensation(reinterpret_cast< CvConDensation * * >( & tmp_condens ));
}

static void cvReleaseFileStorage_d53aa99c3241294fee03f3f038aa2bba( ::CvFileStorage fs ){
    CvFileStorage * tmp_fs = reinterpret_cast< CvFileStorage * >(& fs);
    ::cvReleaseFileStorage(reinterpret_cast< CvFileStorage * * >( & tmp_fs ));
}

static void cvReleaseMemStorage_6ff4687a489093fb83fd38fb1d920837( ::CvMemStorage storage ){
    CvMemStorage * tmp_storage = reinterpret_cast< CvMemStorage * >(& storage);
    ::cvReleaseMemStorage(reinterpret_cast< CvMemStorage * * >( & tmp_storage ));
}

static void cvReleasePOSITObject_679a5da1d4e28b86fdc9a28aa691c6ef( ::CvPOSITObject posit_object ){
    CvPOSITObject * tmp_posit_object = reinterpret_cast< CvPOSITObject * >(& posit_object);
    ::cvReleasePOSITObject(reinterpret_cast< CvPOSITObject * * >( & tmp_posit_object ));
}

static void cvReleaseStereoGCState_f9448f3f98670de75bac96972e1b9d45( ::CvStereoGCState state ){
    CvStereoGCState * tmp_state = reinterpret_cast< CvStereoGCState * >(& state);
    ::cvReleaseStereoGCState(reinterpret_cast< CvStereoGCState * * >( & tmp_state ));
}

static void cvReprojectImageTo3D_4ca87cd67ba33150d51d345f21a24447( ::cv::Mat & disparityImage, ::cv::Mat & _3dImage, ::cv::Mat & Q, int handleMissingValues=0 ){
    ::cvReprojectImageTo3D(get_CvMat_ptr(disparityImage), get_CvMat_ptr(_3dImage), get_CvMat_ptr(Q), handleMissingValues);
}

static void cvRunningAvg_16515bd00db4472140aa21554e25bbc7( ::cv::Mat & image, ::cv::Mat & acc, double alpha, ::cv::Mat mask=cv::Mat() ){
    ::cvRunningAvg(get_CvMat_ptr(image), get_CvMat_ptr(acc), alpha, get_CvMat_ptr(mask));
}

static boost::python::object cvSURFPoint_c0d89cc1fa2a754074aaa768acb95f48( const ::cv::Point2f & pt, int laplacian, int size, float dir=0, float hessian=0 ){
    ::CvSURFPoint result = ::cvSURFPoint((CvPoint2D32f)(pt), laplacian, size, dir, hessian);
    return bp::object( result );
}

static boost::python::object cvSampleLine_9eb7a74db955c3538aef5be3e7392fc5( ::cv::Mat & image, ::CvPoint pt1, ::CvPoint pt2, void * buffer, int connectivity=8 ){
    int result = ::cvSampleLine(get_CvMat_ptr(image), pt1, pt2, buffer, connectivity);
    return bp::object( result );
}

static boost::python::object cvSegmentImage_7b95313fd97ffe28d678124b5aa0a301( ::cv::Mat & srcarr, ::cv::Mat & dstarr, double canny_threshold, double ffill_threshold, ::CvMemStorage * storage ){
    ::CvSeq * result = ::cvSegmentImage(get_CvMat_ptr(srcarr), get_CvMat_ptr(dstarr), canny_threshold, ffill_threshold, storage);
    typedef bp::with_custodian_and_ward_postcall< 0, 5, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static boost::python::object cvSegmentMotion_ed831c1d8f816ea759222aec4d41f1f0( ::cv::Mat & mhi, ::cv::Mat & seg_mask, ::CvMemStorage * storage, double timestamp, double seg_thresh ){
    ::CvSeq * result = ::cvSegmentMotion(get_CvMat_ptr(mhi), get_CvMat_ptr(seg_mask), storage, timestamp, seg_thresh);
    typedef bp::with_custodian_and_ward_postcall< 0, 3, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSeq * >( result ) );
}

static void cvSeqInsertSlice_870f54253b0103a244c6ac596f2820c4( ::CvSeq * seq, int before_index, ::cv::Mat & from_arr ){
    ::cvSeqInsertSlice(seq, before_index, get_CvMat_ptr(from_arr));
}

static void cvSetHistBinRanges_09cb8cb8a16af84266aeebdf9d86df3f( ::CvHistogram * hist, boost::python::object ranges, int uniform=1 ){
    typedef float *LP_ranges;
    bool b_ranges = (ranges.ptr() != Py_None);
    int i_ranges, j_ranges, n0_ranges = b_ranges? bp::len(ranges): 0;
    int *n1_ranges = b_ranges? new int [n0_ranges]: NULL;
    LP_ranges *buf_ranges = b_ranges? new LP_ranges [n0_ranges]: NULL;
    for(i_ranges = 0; i_ranges < n0_ranges; ++i_ranges)
    {
        bp::object const &obj_ranges = ranges[i_ranges];
        n1_ranges[i_ranges] = bp::len(obj_ranges);
        buf_ranges[i_ranges] = new float [n1_ranges[i_ranges]];
        for(j_ranges = 0; j_ranges < n1_ranges[i_ranges]; ++j_ranges)
            buf_ranges[i_ranges][j_ranges] = bp::extract< float > ( obj_ranges[j_ranges] );
    }
        
    ::cvSetHistBinRanges(hist, (float * *) buf_ranges, uniform);
    if(b_ranges)
    {
        for(i_ranges = 0; i_ranges < n0_ranges; ++i_ranges) delete[] buf_ranges[i_ranges];
        delete[] n1_ranges;
        delete[] buf_ranges;
    }
        
}

static boost::python::object cvSetMouseCallback_c212defec0903d7de57c5c0b0ee9b03d( char const * window_name, boost::python::object on_mouse, boost::python::object param=bp::object() ){
    boost::python::tuple z_on_mouse= bp::make_tuple(on_mouse, param);
    ::cvSetMouseCallback(window_name, sdMouseCallback, (void *)(z_on_mouse.ptr()));
    typedef bp::return_value_policy< bp::reference_existing_object > call_policies_t;
    return bp::object( z_on_mouse );
}

static void cvSmooth_77e0c983f4273497b4a61c0a6dcda04f( ::cv::Mat & src, ::cv::Mat & dst, int smoothtype=2, int size1=3, int size2=0, double sigma1=0, double sigma2=0 ){
    ::cvSmooth(get_CvMat_ptr(src), get_CvMat_ptr(dst), smoothtype, size1, size2, sigma1, sigma2);
}

static void cvSnakeImage_12c505f189b0be3fa57d4cc42c364735( ::cv::Mat & image, ::CvPoint * points, int length, boost::python::object alpha, boost::python::object beta, boost::python::object gamma, int coeff_usage, ::CvSize win, ::CvTermCriteria criteria, int calc_gradient=1 ){
    bool b_alpha= alpha.ptr() != Py_None;
    int l_alpha= b_alpha? bp::len(alpha): 0;
    bool b_beta= beta.ptr() != Py_None;
    int l_beta= b_beta? bp::len(beta): 0;
    bool b_gamma= gamma.ptr() != Py_None;
    int l_gamma= b_gamma? bp::len(gamma): 0;
    std::vector< float > v_alpha(l_alpha);
    if(l_alpha > 0) for(int i_alpha = 0; i_alpha < l_alpha; ++i_alpha) v_alpha[i_alpha] = bp::extract< float >(alpha[i_alpha]);
    
    std::vector< float > v_beta(l_beta);
    if(l_beta > 0) for(int i_beta = 0; i_beta < l_beta; ++i_beta) v_beta[i_beta] = bp::extract< float >(beta[i_beta]);
    
    std::vector< float > v_gamma(l_gamma);
    if(l_gamma > 0) for(int i_gamma = 0; i_gamma < l_gamma; ++i_gamma) v_gamma[i_gamma] = bp::extract< float >(gamma[i_gamma]);
    
    ::cvSnakeImage(get_IplImage_ptr(image), points, length, b_alpha? (& (v_alpha.front())): 0, b_beta? (& (v_beta.front())): 0, b_gamma? (& (v_gamma.front())): 0, coeff_usage, win, criteria, calc_gradient);
}

static boost::python::object cvSolveCubic_97d0ac3b0fc6ba46cd5b5f2eaea79583( ::cv::Mat & coeffs, ::cv::Mat & roots ){
    int result = ::cvSolveCubic(get_CvMat_ptr(coeffs), get_CvMat_ptr(roots));
    return bp::object( result );
}

static void cvSolvePoly_a7fe4b7abe368e2e780716aa49dc8f82( ::cv::Mat & coeffs, ::cv::Mat & roots2, int maxiter=20, int fig=100 ){
    ::cvSolvePoly(get_CvMat_ptr(coeffs), get_CvMat_ptr(roots2), maxiter, fig);
}

static void cvSquareAcc_df8ad076f822a2856ccecbbdf6a2b2b0( ::cv::Mat & image, ::cv::Mat & sqsum, ::cv::Mat mask=cv::Mat() ){
    ::cvSquareAcc(get_CvMat_ptr(image), get_CvMat_ptr(sqsum), get_CvMat_ptr(mask));
}

static boost::python::object cvStartFindContours_1914ce1dccb0d5710ebdf49d4c3d96cc( ::cv::Mat & image, ::CvMemStorage * storage, int header_size=88u, int mode=1, int method=2, ::CvPoint offset=cv::Point(0, 0) ){
    ::CvContourScanner result = ::cvStartFindContours(get_CvMat_ptr(image), storage, header_size, mode, method, offset);
    typedef bp::with_ownershiplevel_postcall< 1, bp::with_custodian_and_ward_postcall< 0, 2, bp::return_value_policy< bp::reference_existing_object > > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvContourScanner >( result ) );
}

static void cvStartNextStream_db71e53dfa9475145f4487a80d5d8bf2( ::cv::FileStorage & fs ){
    ::cvStartNextStream(fs.fs);
}

static void cvStartReadRawData_4fe1fcc06b3f886cb6549cad64e1d1a0( ::CvFileStorage const * fs, ::cv::FileNode const & src, ::CvSeqReader * reader ){
    ::cvStartReadRawData(fs, *(src), reader);
}

static void cvStartWriteStruct_e7e2128639c3a858bdb332c89468a8e0( ::cv::FileStorage & fs, char const * name, int struct_flags, char const * type_name=0, ::CvAttrList attributes=cvAttrList(0u, 0u) ){
    ::cvStartWriteStruct(fs.fs, name, struct_flags, type_name, attributes);
}

static boost::python::tuple cvSubdiv2DLocate_1df86dbc29fc9de6df2bbdb2196d6db3( ::CvSubdiv2D * subdiv, const ::cv::Point2f & pt, ::CvSubdiv2DEdge * edge ){
    CvSubdiv2DPoint * vertex2=(::CvSubdiv2DPoint *)0;
    ::CvSubdiv2DPointLocation result = ::cvSubdiv2DLocate(subdiv, (CvPoint2D32f)(pt), edge, &vertex2);
    return bp::make_tuple( result, vertex2 );
}

static boost::python::object cvSubdivDelaunay2DInsert_0d66ff0b2bc8918d0793f968404f1cb2( ::CvSubdiv2D * subdiv, const ::cv::Point2f & pt ){
    ::CvSubdiv2DPoint * result = ::cvSubdivDelaunay2DInsert(subdiv, (CvPoint2D32f)(pt));
    typedef bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvSubdiv2DPoint * >( result ) );
}

static boost::python::object cvTriangleArea_727599fdabcae9fb78274a766e9dac94( const ::cv::Point2f & a, const ::cv::Point2f & b, const ::cv::Point2f & c ){
    double result = ::cvTriangleArea((CvPoint2D32f)(a), (CvPoint2D32f)(b), (CvPoint2D32f)(c));
    return bp::object( result );
}

static void cvTriangulatePoints_eb948ff6300aa4ebf4fad0ec7d6d4e78( ::cv::Mat & projMatr1, ::cv::Mat & projMatr2, ::cv::Mat & projPoints1, ::cv::Mat & projPoints2, ::cv::Mat & points4D ){
    ::cvTriangulatePoints(get_CvMat_ptr(projMatr1), get_CvMat_ptr(projMatr2), get_CvMat_ptr(projPoints1), get_CvMat_ptr(projPoints2), get_CvMat_ptr(points4D));
}

static boost::python::object cvTypeOf_4e7bd20b082b35b68253f04b04f578ce( ::CvArr * struct_ptr ){
    ::CvTypeInfo * result = ::cvTypeOf(reinterpret_cast< void const * >( struct_ptr ));
    typedef bp::return_value_policy< bp::reference_existing_object > call_policies_t;
    return bp::object( pyplusplus::call_policies::make_object< call_policies_t, ::CvTypeInfo * >( result ) );
}

static void cvUpdateMotionHistory_fb635b1eb55f77d94f46a70f41eac0b3( ::cv::Mat & silhouette, ::cv::Mat & mhi, double timestamp, double duration ){
    ::cvUpdateMotionHistory(get_CvMat_ptr(silhouette), get_CvMat_ptr(mhi), timestamp, duration);
}

static void cvWrite_00335cc764e72fb9408450c10fffab4a( ::cv::FileStorage & fs, char const * name, const char * ptr, ::CvAttrList attributes=cvAttrList(0u, 0u) ){
    ::cvWrite(fs.fs, name, ((void const *) ptr), attributes);
}

static void cvWriteComment_3e89473031f5fbea0ed6232440721138( ::cv::FileStorage & fs, char const * comment, int eol_comment ){
    ::cvWriteComment(fs.fs, comment, eol_comment);
}

static void cvWriteFileNode_4df1ea107367e738fdd6f88f15146fb9( ::cv::FileStorage & fs, char const * new_node_name, ::cv::FileNode const & node, int embed ){
    ::cvWriteFileNode(fs.fs, new_node_name, *(node), embed);
}

static void cvWriteInt_3ee9f31ea1735f25d28b6cfc1e87078a( ::cv::FileStorage & fs, char const * name, int value ){
    ::cvWriteInt(fs.fs, name, value);
}

static void cvWriteReal_2c8a3a2d5d1328049eb47e9ef6cc9282( ::cv::FileStorage & fs, char const * name, double value ){
    ::cvWriteReal(fs.fs, name, value);
}

static void cvWriteString_72043510addf587750a274c07091202d( ::cv::FileStorage & fs, char const * name, char const * str, int quote=0 ){
    ::cvWriteString(fs.fs, name, str, quote);
}

static void drawContours_03a5aed7ca57b253d8b3346ee2f05f74( ::cv::Mat & image, bp::tuple contours, int contourIdx, ::cv::Scalar const & color, int thickness=1, int lineType=8, bp::tuple hierarchy=convert_vector_to_seq(std::vector<cv::Vec4i>()), int maxLevel=2147483647, ::cv::Point offset=cv::Point_<int>() ){
    std::vector<std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > >, std::allocator<std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > > > > contours2;
    std::vector<cv::Vec<int, 4>, std::allocator<cv::Vec<int, 4> > > hierarchy2;
    convert_seq_to_vector_vector(contours, contours2);
    convert_seq_to_vector(hierarchy, hierarchy2);
    ::cv::drawContours(image, contours2, contourIdx, color, thickness, lineType, hierarchy2, maxLevel, offset);
}

static boost::python::object ellipse2Poly_a1937ebf152fa736fc27822db2e0081a( ::cv::Point center, ::cv::Size axes, int angle, int arcStart, int arcEnd, int delta, bp::tuple pts ){
    std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > > pts2;
    convert_seq_to_vector(pts, pts2);
    ::cv::ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta, pts2);
    pts = convert_vector_to_seq(pts2);
    return bp::object( pts );
}

static boost::python::tuple estimateAffine3D_fd3dca5e5fd5d2ce4664db813a2c08bf( ::cv::Mat const & from, ::cv::Mat const & to, ::cv::Mat & out, bp::tuple outliers, double param1=3.0e+0, double param2=9.89999999999999991118215802998747676610946655273e-1 ){
    std::vector<unsigned char, std::allocator<unsigned char> > outliers2;
    convert_seq_to_vector(outliers, outliers2);
    int result = ::cv::estimateAffine3D(from, to, out, outliers2, param1, param2);
    outliers = convert_vector_to_seq(outliers2);
    return bp::make_tuple( result, outliers );
}

static void fillConvexPoly_1312287b0cded13c02c57cc3d8ebf4b4( ::cv::Mat & img, boost::python::object pts, ::cv::Scalar const & color, int lineType=8, int shift=0 ){
    bool b_pts= pts.ptr() != Py_None;
    int l_pts= b_pts? bp::len(pts): 0;
    std::vector< ::cv::Point_<int> > v_pts(l_pts);
    if(l_pts > 0) for(int i_pts = 0; i_pts < l_pts; ++i_pts) v_pts[i_pts] = bp::extract< ::cv::Point_<int> >(pts[i_pts]);
    
    ::cv::fillConvexPoly(img, b_pts? (& (v_pts.front())): 0, l_pts, color, lineType, shift);
}

static void fillPoly_e862cfcf1208f193efcd2bec59b744ec( ::cv::Mat & img, boost::python::object pts, ::cv::Scalar const & color, int lineType=8, int shift=0, ::cv::Point offset=cv::Point_<int>() ){
    typedef ::cv::Point_<int> *LP_pts;
    bool b_pts = (pts.ptr() != Py_None);
    int i_pts, j_pts, n0_pts = b_pts? bp::len(pts): 0;
    int *n1_pts = b_pts? new int [n0_pts]: NULL;
    LP_pts *buf_pts = b_pts? new LP_pts [n0_pts]: NULL;
    for(i_pts = 0; i_pts < n0_pts; ++i_pts)
    {
        bp::object const &obj_pts = pts[i_pts];
        n1_pts[i_pts] = bp::len(obj_pts);
        buf_pts[i_pts] = new ::cv::Point_<int> [n1_pts[i_pts]];
        for(j_pts = 0; j_pts < n1_pts[i_pts]; ++j_pts)
            buf_pts[i_pts][j_pts] = bp::extract< ::cv::Point_<int> > ( obj_pts[j_pts] );
    }
        
    ::cv::fillPoly(img, (::cv::Point const * *) buf_pts, n1_pts, n0_pts, color, lineType, shift, offset);
    if(b_pts)
    {
        for(i_pts = 0; i_pts < n0_pts; ++i_pts) delete[] buf_pts[i_pts];
        delete[] n1_pts;
        delete[] buf_pts;
    }
        
}

static boost::python::tuple findChessboardCorners_dbf15a4ace0e613206118382aa1793ea( ::cv::Mat const & image, ::cv::Size patternSize, int flags=3 ){
    bp::tuple corners2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > corners3;
    bool result = ::cv::findChessboardCorners(image, patternSize, corners3, flags);
    corners2 = convert_vector_to_seq(corners3);
    return bp::make_tuple( result, corners2 );
}

static boost::python::tuple findContours_68285032b2b0f15f13e30f19da8327fa( ::cv::Mat const & image, int mode, int method, ::cv::Point offset=cv::Point_<int>() ){
    bp::tuple contours2;
    std::vector<std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > >, std::allocator<std::vector<cv::Point_<int>, std::allocator<cv::Point_<int> > > > > contours3;
    bp::tuple hierarchy2;
    std::vector<cv::Vec<int, 4>, std::allocator<cv::Vec<int, 4> > > hierarchy3;
    ::cv::findContours(image, contours3, hierarchy3, mode, method, offset);
    contours2 = convert_vector_vector_to_seq(contours3);
    hierarchy2 = convert_vector_to_seq(hierarchy3);
    return bp::make_tuple( contours2, hierarchy2 );
}

static boost::python::tuple findFundamentalMat_4b8947da99452ee36abb2b044e941f4a( ::cv::Mat const & points1, ::cv::Mat const & points2, int method=int(::cv::FM_RANSAC), double param1=3.0e+0, double param2=9.89999999999999991118215802998747676610946655273e-1 ){
    bp::tuple mask2;
    std::vector<unsigned char, std::allocator<unsigned char> > mask3;
    ::cv::Mat result = ::cv::findFundamentalMat(points1, points2, mask3, method, param1, param2);
    mask2 = convert_vector_to_seq(mask3);
    return bp::make_tuple( result, mask2 );
}

static boost::python::tuple findHomography_43999ba4bb258d7c74f144c8915f1665( ::cv::Mat const & srcPoints, ::cv::Mat const & dstPoints, int method=0, double ransacReprojThreshold=0 ){
    bp::tuple mask2;
    std::vector<unsigned char, std::allocator<unsigned char> > mask3;
    ::cv::Mat result = ::cv::findHomography(srcPoints, dstPoints, mask3, method, ransacReprojThreshold);
    mask2 = convert_vector_to_seq(mask3);
    return bp::make_tuple( result, mask2 );
}

static boost::python::tuple floodFill_a833ccdf7b45572779d5c63d9adc2b15( ::cv::Mat & image, ::cv::Mat & mask, ::cv::Point seedPoint, ::cv::Scalar newVal, ::cv::Scalar loDiff=cv::Scalar_<double>(), ::cv::Scalar upDiff=cv::Scalar_<double>(), int flags=4 ){
    cv::Rect_<int> rect2;
    int result = ::cv::floodFill(image, mask, seedPoint, newVal, &rect2, loDiff, upDiff, flags);
    return bp::make_tuple( result, rect2 );
}

static boost::python::tuple floodFill_75a8a8f3e3e22b4d281bb304a7881151( ::cv::Mat & image, ::cv::Point seedPoint, ::cv::Scalar newVal, ::cv::Scalar loDiff=cv::Scalar_<double>(), ::cv::Scalar upDiff=cv::Scalar_<double>(), int flags=4 ){
    cv::Rect_<int> rect2;
    int result = ::cv::floodFill(image, seedPoint, newVal, &rect2, loDiff, upDiff, flags);
    return bp::make_tuple( result, rect2 );
}

static boost::python::object getAffineTransform_aa493630c3e4efe1ff49141fe5060922( boost::python::object src, boost::python::object dst ){
    bool b_src= src.ptr() != Py_None;
    int l_src= b_src? bp::len(src): 0;
    bool b_dst= dst.ptr() != Py_None;
    int l_dst= b_dst? bp::len(dst): 0;
    std::vector< ::cv::Point_<float> > v_src(l_src);
    if(l_src > 0) for(int i_src = 0; i_src < l_src; ++i_src) v_src[i_src] = bp::extract< ::cv::Point_<float> >(src[i_src]);
    
    std::vector< ::cv::Point_<float> > v_dst(l_dst);
    if(l_dst > 0) for(int i_dst = 0; i_dst < l_dst; ++i_dst) v_dst[i_dst] = bp::extract< ::cv::Point_<float> >(dst[i_dst]);
    
    ::cv::Mat result = ::cv::getAffineTransform(b_src? (& (v_src.front())): 0, b_dst? (& (v_dst.front())): 0);
    return bp::object( result );
}

static boost::python::object getPerspectiveTransform_c06a0392152cb20f6b57ae1ff2ac2c11( boost::python::object src, boost::python::object dst ){
    bool b_src= src.ptr() != Py_None;
    int l_src= b_src? bp::len(src): 0;
    bool b_dst= dst.ptr() != Py_None;
    int l_dst= b_dst? bp::len(dst): 0;
    std::vector< ::cv::Point_<float> > v_src(l_src);
    if(l_src > 0) for(int i_src = 0; i_src < l_src; ++i_src) v_src[i_src] = bp::extract< ::cv::Point_<float> >(src[i_src]);
    
    std::vector< ::cv::Point_<float> > v_dst(l_dst);
    if(l_dst > 0) for(int i_dst = 0; i_dst < l_dst; ++i_dst) v_dst[i_dst] = bp::extract< ::cv::Point_<float> >(dst[i_dst]);
    
    ::cv::Mat result = ::cv::getPerspectiveTransform(b_src? (& (v_src.front())): 0, b_dst? (& (v_dst.front())): 0);
    return bp::object( result );
}

static boost::python::tuple getTextSize_efe6452b14ca0fcca5a50ca33199f5e7( ::std::string const & text, int fontFace, double fontScale, int thickness ){
    int baseLine2;
    ::cv::Size result = ::cv::getTextSize(text, fontFace, fontScale, thickness, &baseLine2);
    return bp::make_tuple( result, baseLine2 );
}

static boost::python::object goodFeaturesToTrack_a887e3eb7b667339b1ac0c1a02f5735c( ::cv::Mat const & image, int maxCorners, double qualityLevel, double minDistance, ::cv::Mat const & mask=cv::Mat(), int blockSize=3, bool useHarrisDetector=false, double k=4.00000000000000008326672684688674053177237510681e-2 ){
    bp::tuple corners2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > corners3;
    ::cv::goodFeaturesToTrack(image, corners3, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k);
    corners2 = convert_vector_to_seq(corners3);
    return bp::object( corners2 );
}

static boost::python::object groupRectangles_daddb1eb144574c44042d3cef39f8656( bp::tuple rectList, int groupThreshold, double eps=2.00000000000000011102230246251565404236316680908e-1 ){
    std::vector<cv::Rect_<int>, std::allocator<cv::Rect_<int> > > rectList2;
    convert_seq_to_vector(rectList, rectList2);
    ::cv::groupRectangles(rectList2, groupThreshold, eps);
    rectList = convert_vector_to_seq(rectList2);
    return bp::object( rectList );
}

static boost::python::tuple imencode_7058867f40db2ceceebdc74b4943c841( ::std::string const & ext, ::cv::Mat const & img, bp::tuple params=convert_vector_to_seq(std::vector<int>()) ){
    bp::tuple buf2;
    std::vector<unsigned char, std::allocator<unsigned char> > buf3;
    std::vector<int, std::allocator<int> > params2;
    convert_seq_to_vector(params, params2);
    bool result = ::cv::imencode(ext, img, buf3, params2);
    buf2 = convert_vector_to_seq(buf3);
    return bp::make_tuple( result, buf2 );
}

static boost::python::object imwrite_08123c4d4c07e7af51577328378c9683( ::std::string const & filename, ::cv::Mat const & img, bp::tuple params=convert_vector_to_seq(std::vector<int>()) ){
    std::vector<int, std::allocator<int> > params2;
    convert_seq_to_vector(params, params2);
    bool result = ::cv::imwrite(filename, img, params2);
    return bp::object( result );
}

static boost::python::object initCameraMatrix2D_a63e0813c9e7ddf60786347e47acca95( bp::tuple objectPoints, bp::tuple imagePoints, ::cv::Size imageSize, double aspectRatio=1.0e+0 ){
    std::vector<std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > >, std::allocator<std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > > > > objectPoints2;
    std::vector<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > >, std::allocator<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > > > imagePoints2;
    convert_seq_to_vector_vector(objectPoints, objectPoints2);
    convert_seq_to_vector_vector(imagePoints, imagePoints2);
    ::cv::Mat result = ::cv::initCameraMatrix2D(objectPoints2, imagePoints2, imageSize, aspectRatio);
    return bp::object( result );
}

static boost::python::tuple kmeans_7acc1faebc4e430dbd210d93113e85c9( ::cv::Mat const & data, int K, ::cv::Mat & best_labels, ::cv::TermCriteria criteria, int attempts, int flags ){
    cv::Mat centers2;
    double result = ::cv::kmeans(data, K, best_labels, criteria, attempts, flags, &centers2);
    return bp::make_tuple( result, centers2 );
}

static void merge_3b2d3618a31ce673ada132517e890dcb( boost::python::object mvbegin, ::cv::MatND & dst ){
    bool b_mvbegin= mvbegin.ptr() != Py_None;
    int l_mvbegin= b_mvbegin? bp::len(mvbegin): 0;
    std::vector< ::cv::MatND > v_mvbegin(l_mvbegin);
    if(l_mvbegin > 0) for(int i_mvbegin = 0; i_mvbegin < l_mvbegin; ++i_mvbegin) v_mvbegin[i_mvbegin] = bp::extract< ::cv::MatND >(mvbegin[i_mvbegin]);
    
    ::cv::merge(b_mvbegin? (& (v_mvbegin.front())): 0, l_mvbegin, dst);
}

static void merge_a47eeb2aff422ee6c05b5574cb0848fe( boost::python::object mv, ::cv::Mat & dst ){
    bool b_mv= mv.ptr() != Py_None;
    int l_mv= b_mv? bp::len(mv): 0;
    std::vector< ::cv::Mat > v_mv(l_mv);
    if(l_mv > 0) for(int i_mv = 0; i_mv < l_mv; ++i_mv) v_mv[i_mv] = bp::extract< ::cv::Mat >(mv[i_mv]);
    
    ::cv::merge(b_mv? (& (v_mv.front())): 0, l_mv, dst);
}

static void polylines_4b2b9aca4a0ee1864678eae6b982fcc0( ::cv::Mat & img, boost::python::object pts, bool isClosed, ::cv::Scalar const & color, int thickness=1, int lineType=8, int shift=0 ){
    typedef ::cv::Point_<int> *LP_pts;
    bool b_pts = (pts.ptr() != Py_None);
    int i_pts, j_pts, n0_pts = b_pts? bp::len(pts): 0;
    int *n1_pts = b_pts? new int [n0_pts]: NULL;
    LP_pts *buf_pts = b_pts? new LP_pts [n0_pts]: NULL;
    for(i_pts = 0; i_pts < n0_pts; ++i_pts)
    {
        bp::object const &obj_pts = pts[i_pts];
        n1_pts[i_pts] = bp::len(obj_pts);
        buf_pts[i_pts] = new ::cv::Point_<int> [n1_pts[i_pts]];
        for(j_pts = 0; j_pts < n1_pts[i_pts]; ++j_pts)
            buf_pts[i_pts][j_pts] = bp::extract< ::cv::Point_<int> > ( obj_pts[j_pts] );
    }
        
    ::cv::polylines(img, (::cv::Point const * *) buf_pts, n1_pts, n0_pts, isClosed, color, thickness, lineType, shift);
    if(b_pts)
    {
        for(i_pts = 0; i_pts < n0_pts; ++i_pts) delete[] buf_pts[i_pts];
        delete[] n1_pts;
        delete[] buf_pts;
    }
        
}

static boost::python::object projectPoints_c3cbd5f3e0c4a976b617302062632da4( ::cv::Mat const & objectPoints, ::cv::Mat const & rvec, ::cv::Mat const & tvec, ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs, ::cv::Mat & dpdrot, ::cv::Mat & dpdt, ::cv::Mat & dpdf, ::cv::Mat & dpdc, ::cv::Mat & dpddist, double aspectRatio=0 ){
    bp::tuple imagePoints2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > imagePoints3;
    ::cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints3, dpdrot, dpdt, dpdf, dpdc, dpddist, aspectRatio);
    imagePoints2 = convert_vector_to_seq(imagePoints3);
    return bp::object( imagePoints2 );
}

static boost::python::object projectPoints_ce9cea7b4fadb5986d2a47a4d012fac0( ::cv::Mat const & objectPoints, ::cv::Mat const & rvec, ::cv::Mat const & tvec, ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs ){
    bp::tuple imagePoints2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > imagePoints3;
    ::cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints3);
    imagePoints2 = convert_vector_to_seq(imagePoints3);
    return bp::object( imagePoints2 );
}

static boost::python::object read_19f776a07d0494421b17575379bc2106( ::cv::FileNode const & node ){
    bp::tuple keypoints2;
    std::vector<cv::KeyPoint, std::allocator<cv::KeyPoint> > keypoints3;
    ::cv::read(node, keypoints3);
    keypoints2 = convert_vector_to_seq(keypoints3);
    return bp::object( keypoints2 );
}

static boost::python::object read_70c5e2668ef6bb953f654143837a7095( ::cv::FileNode const & node, ::cv::SparseMat const & default_mat=cv::SparseMat() ){
    cv::SparseMat mat2;
    ::cv::read(node, mat2, default_mat);
    return bp::object( mat2 );
}

static boost::python::object read_fcf3602693271e7c8a4e15ff65aede4c( ::cv::FileNode const & node, ::cv::MatND const & default_mat=cv::MatND() ){
    cv::MatND mat2;
    ::cv::read(node, mat2, default_mat);
    return bp::object( mat2 );
}

static boost::python::object read_fd962997898e5b5f59cbef9efc942bcd( ::cv::FileNode const & node, ::cv::Mat const & default_mat=cv::Mat() ){
    cv::Mat mat2;
    ::cv::read(node, mat2, default_mat);
    return bp::object( mat2 );
}

static boost::python::object read_31e582223a7f98972af6d67b7558569e( ::cv::FileNode const & node, ::std::string const & default_value ){
    std::basic_string<char,std::char_traits<char>,std::allocator<char> > value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_9a054275260bdb7b0741c9b9e8cf5aae( ::cv::FileNode const & node, double default_value ){
    double value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_9b06f36c44aa0d63d7f9f36cebc8d25f( ::cv::FileNode const & node, float default_value ){
    float value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_29c2b389d482b9f6d13cfbe5d7264926( ::cv::FileNode const & node, int default_value ){
    int value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_62eac78db6563e1e714f1e282bf790db( ::cv::FileNode const & node, short int default_value ){
    short int value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_81b0a1f4d595a311c77148001bd0046d( ::cv::FileNode const & node, ::ushort default_value ){
    short unsigned int value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_b68923bb48bf8de904fed0f0570414f5( ::cv::FileNode const & node, ::schar default_value ){
    signed char value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_e3dbdb6033985682cd13b98ac06df84e( ::cv::FileNode const & node, ::uchar default_value ){
    unsigned char value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static boost::python::object read_2ba57a356ec17a70685f21fbad5a9438( ::cv::FileNode const & node, bool default_value ){
    bool value2;
    ::cv::read(node, value2, default_value);
    return bp::object( value2 );
}

static void split_2e154aaf70f5c323ceec9f447e404d8a( ::cv::MatND const & m, boost::python::object mv ){
    bool b_mv= mv.ptr() != Py_None;
    int l_mv= b_mv? bp::len(mv): 0;
    std::vector< ::cv::MatND > v_mv(l_mv);
    if(l_mv > 0) for(int i_mv = 0; i_mv < l_mv; ++i_mv) v_mv[i_mv] = bp::extract< ::cv::MatND >(mv[i_mv]);
    
    ::cv::split(m, b_mv? (& (v_mv.front())): 0);
}

static void split_d88fca83dae3e7420e6688bbbcd2ac41( ::cv::Mat const & m, boost::python::object mvbegin ){
    bool b_mvbegin= mvbegin.ptr() != Py_None;
    int l_mvbegin= b_mvbegin? bp::len(mvbegin): 0;
    std::vector< ::cv::Mat > v_mvbegin(l_mvbegin);
    if(l_mvbegin > 0) for(int i_mvbegin = 0; i_mvbegin < l_mvbegin; ++i_mvbegin) v_mvbegin[i_mvbegin] = bp::extract< ::cv::Mat >(mvbegin[i_mvbegin]);
    
    ::cv::split(m, b_mvbegin? (& (v_mvbegin.front())): 0);
}

static void stereoCalibrate_14726b7172922289400130b4861f4a12( bp::tuple objectPoints, bp::tuple imagePoints1, bp::tuple imagePoints2, ::cv::Mat & cameraMatrix1, ::cv::Mat & distCoeffs1, ::cv::Mat & cameraMatrix2, ::cv::Mat & distCoeffs2, ::cv::Size imageSize, ::cv::Mat & R, ::cv::Mat & T, ::cv::Mat & E, ::cv::Mat & F, ::cv::TermCriteria criteria=cv::TermCriteria(3, 30, 9.99999999999999954748111825886258685613938723691e-7), int flags=int(::cv::CALIB_FIX_INTRINSIC) ){
    std::vector<std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > >, std::allocator<std::vector<cv::Point3_<float>, std::allocator<cv::Point3_<float> > > > > objectPoints2;
    std::vector<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > >, std::allocator<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > > > imagePoints12;
    std::vector<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > >, std::allocator<std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > > > imagePoints22;
    convert_seq_to_vector_vector(objectPoints, objectPoints2);
    convert_seq_to_vector_vector(imagePoints1, imagePoints12);
    convert_seq_to_vector_vector(imagePoints2, imagePoints22);
    ::cv::stereoCalibrate(objectPoints2, imagePoints12, imagePoints22, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, criteria, flags);
}

static boost::python::object undistortPoints_e5fdbe55500ffb118c2a9845da49f34b( ::cv::Mat const & src, ::cv::Mat const & cameraMatrix, ::cv::Mat const & distCoeffs, ::cv::Mat const & R=cv::Mat(), ::cv::Mat const & P=cv::Mat() ){
    bp::tuple dst2;
    std::vector<cv::Point_<float>, std::allocator<cv::Point_<float> > > dst3;
    ::cv::undistortPoints(src, dst3, cameraMatrix, distCoeffs, R, P);
    dst2 = convert_vector_to_seq(dst3);
    return bp::object( dst2 );
}

static void write_df76e3ba45561ddd23c917a610929778( ::cv::FileStorage & fs, ::std::string const & name, bp::tuple keypoints ){
    std::vector<cv::KeyPoint, std::allocator<cv::KeyPoint> > keypoints2;
    convert_seq_to_vector(keypoints, keypoints2);
    ::cv::write(fs, name, keypoints2);
}

struct CvRNG_to_python
{
    static PyObject* convert(CvRNG const& x)
    {
        return bp::incref(bp::object(cv::RNG(x)).ptr());
    }
};

struct CvRect_to_python
{
    static PyObject* convert(CvRect const& x)
    {
        return bp::incref(bp::object(cv::Rect(x)).ptr());
    }
};

struct CvScalar_to_python
{
    static PyObject* convert(CvScalar const& x)
    {
        return bp::incref(bp::object(cv::Scalar(x)).ptr());
    }
};

struct CvPoint_to_python
{
    static PyObject* convert(CvPoint const& x)
    {
        return bp::incref(bp::object(cv::Point(x)).ptr());
    }
};

struct CvPoint2D32f_to_python
{
    static PyObject* convert(CvPoint2D32f const& x)
    {
        return bp::incref(bp::object(cv::Point2f(x)).ptr());
    }
};

struct CvPoint3D32f_to_python
{
    static PyObject* convert(CvPoint3D32f const& x)
    {
        return bp::incref(bp::object(cv::Point3f(x)).ptr());
    }
};


struct CvSize_to_python
{
    static PyObject* convert(CvSize const& x)
    {
        return bp::incref(bp::object(cv::Size(x)).ptr());
    }
};

struct CvBox2D_to_python
{
    static PyObject* convert(CvBox2D const& x)
    {
        return bp::incref(bp::object(cv::RotatedRect(x)).ptr());
    }
};

struct CvTermCriteria_to_python
{
    static PyObject* convert(CvTermCriteria const& x)
    {
        return bp::incref(bp::object(cv::TermCriteria(x)).ptr());
    }
};

struct CvSlice_to_python
{
    static PyObject* convert(CvSlice const& x)
    {
        return bp::incref(bp::object(cv::Range(x)).ptr());
    }
};

struct CvMatND_to_python
{
    static PyObject* convert(CvMatND const& x)
    {
        return bp::incref(bp::object(cv::MatND(&x)).ptr());
    }
};

static void sd_calcHist( bp::tuple const & images, bp::tuple const & channels, 
    ::cv::Mat const & mask, bp::object &hist, int dims, bp::tuple const & histSize, 
    bp::tuple const & ranges, bool uniform=true, bool accumulate=false ){
    std::vector< cv::Mat > images2; convert_seq_to_vector(images, images2);
    std::vector< int > channels2; convert_seq_to_vector(channels, channels2);
    std::vector< int > histSize2; convert_seq_to_vector(histSize, histSize2);
    std::vector< std::vector < float > > ranges2; convert_seq_to_vector_vector(ranges, ranges2);
    std::vector< float const * > ranges3;
    ranges3.resize(ranges2.size());
    for(unsigned int i = 0; i < ranges2.size(); ++i ) ranges3[i] = &ranges2[i][0];
    
    bp::extract< ::cv::MatND & > hist_matnd(hist);
    bp::extract< ::cv::SparseMat & > hist_sparsemat(hist);
    
    if(hist_matnd.check())
    {
        cv::MatND &hist_matnd2 = hist_matnd();
        cv::calcHist(&images2[0], images2.size(), &channels2[0], mask,
            hist_matnd2, dims, &histSize2[0], &ranges3[0], uniform, accumulate);
    }
    else if(hist_sparsemat.check())
    {
        cv::SparseMat &hist_sparsemat2 = hist_sparsemat();
        cv::calcHist(&images2[0], images2.size(), &channels2[0], mask,
            hist_sparsemat2, dims, &histSize2[0], &ranges3[0], uniform, accumulate);
    }
    else
    {
        PyErr_SetString(PyExc_NotImplementedError, "Only 'MatND' and 'SparseMat' are acceptable types for argument 'hist'.");
        throw bp::error_already_set(); 
    }
}

static void sd_calcBackProject( bp::tuple const & images, bp::tuple const & channels, 
    bp::object &hist, cv::Mat &backProject, 
    bp::tuple const & ranges, double scale=1, bool uniform=true ){
    std::vector< cv::Mat > images2; convert_seq_to_vector(images, images2);
    std::vector< int > channels2; convert_seq_to_vector(channels, channels2);
    std::vector< std::vector < float > > ranges2; convert_seq_to_vector_vector(ranges, ranges2);
    std::vector< float const * > ranges3;
    ranges3.resize(ranges2.size());
    for(unsigned int i = 0; i < ranges2.size(); ++i ) ranges3[i] = &ranges2[i][0];
    
    bp::extract< ::cv::MatND & > hist_matnd(hist);
    bp::extract< ::cv::SparseMat & > hist_sparsemat(hist);
    
    if(hist_matnd.check())
    {
        cv::MatND &hist_matnd2 = hist_matnd();
        cv::calcBackProject(&images2[0], images2.size(), &channels2[0], 
            hist_matnd2, backProject, &ranges3[0], scale, uniform);
    }
    else if(hist_sparsemat.check())
    {
        cv::SparseMat &hist_sparsemat2 = hist_sparsemat();
        cv::calcBackProject(&images2[0], images2.size(), &channels2[0], 
            hist_sparsemat2, backProject, &ranges3[0], scale, uniform);
    }
    else
    {
        PyErr_SetString(PyExc_NotImplementedError, "Only 'MatND' and 'SparseMat' are acceptable types for argument 'hist'.");
        throw bp::error_already_set(); 
    }
}

static bp::object sd_approxPolyDP( cv::Mat const &curve, double epsilon, bool closed) {
    std::vector<cv::Point> point2i;
    std::vector<cv::Point2f> point2f;
    bp::object obj;
    if(curve.type() == CV_32SC2) 
    {
        cv::approxPolyDP(curve, point2i, epsilon, closed);
        obj = convert_vector_to_seq(point2i);
    }
    else
    {
        cv::approxPolyDP(curve, point2f, epsilon, closed);
        obj = convert_vector_to_seq(point2f);
    }
    return obj;
}

static bp::object sd_convexHull( cv::Mat const &points, bool clockwise=false) {
    std::vector<cv::Point> hull2i;
    std::vector<cv::Point2f> hull2f;
    bp::object obj;
    if(points.type() == CV_32SC2)
    {
        cv::convexHull(points, hull2i, clockwise);
        obj = convert_vector_to_seq(hull2i);
    }
    else
    {
        cv::convexHull(points, hull2f, clockwise);
        obj = convert_vector_to_seq(hull2f);
    }
    return obj;
}

void drawChessboardCorners( cv::Mat& image, cv::Size patternSize, bp::tuple const &corners, bool patternWasFound )
{
    std::vector<cv::Point2f> corners2; convert_seq_to_vector(corners, corners2);
    ::cvDrawChessboardCorners( &(::CvMat)image, patternSize, (CvPoint2D32f*)&corners2[0],
        corners2.size(), patternWasFound );
}

BOOST_PYTHON_MODULE(pyopencvext){
    register_enumerations();

    register_CvANN_MLP_TrainParams_class();

    register_CvStatModel_class();

    register_Mat_class();

    register_CvANN_MLP_class();

    register_CvAdaptiveSkinDetector_class();

    register_CvAttrList_class();

    register_CvAvgComp_class();

    register_CvDTreeParams_class();

    register_CvBoostParams_class();

    register_CvBoost_class();

    register_CvDTreeSplit_class();

    register_CvDTree_class();

    register_CvBoostTree_class();

    register_CvCamShiftTracker_class();

    register_CvChain_class();

    register_CvChainPtReader_class();

    register_CvConDensation_class();

    register_CvConnectedComp_class();

    register_CvContour_class();

    register_CvContourTree_class();

    register_CvConvexityDefect_class();

    register_CvDTreeTrainData_class();

    register_CvEMParams_class();

    register_CvEM_class();

    register_CvRTParams_class();

    register_CvRTrees_class();

    register_CvERTrees_class();

    register_CvFeatureTree_class();

    register_CvFileNode_class();

    register_CvFileStorage_class();

    register_CvForestTree_class();

    register_CvForestERTree_class();

    register_CvFuzzyController_class();

    register_CvFuzzyCurve_class();

    register_CvFuzzyFunction_class();

    register_CvFuzzyMeanShiftTracker_class();

    register_CvFuzzyPoint_class();

    register_CvFuzzyRule_class();

    register_CvGenericHash_class();

    register_CvGraph_class();

    register_CvGraphEdge_class();

    register_CvGraphScanner_class();

    register_CvGraphVtx_class();

    register_CvGraphVtx2D_class();

    register_CvHaarClassifier_class();

    register_CvHaarClassifierCascade_class();

    register_CvHaarFeature_class();

    register_CvHaarStageClassifier_class();

    register_CvHistogram_class();

    register_CvKNearest_class();

    register_CvLSH_class();

    register_CvLSHOperations_class();

    register_CvLevMarq_class();

    register_CvMLData_class();

    register_CvMSERParams_class();

    register_CvMemBlock_class();

    register_CvMemStorage_class();

    register_CvMemStoragePos_class();

    register_CvModule_class();

    register_CvModuleInfo_class();

    register_CvNArrayIterator_class();

    register_CvNormalBayesClassifier_class();

    register_CvPOSITObject_class();

    register_CvParamGrid_class();

    register_CvPluginFuncInfo_class();

    register_CvQuadEdge2D_class();

    register_CvSURFParams_class();

    register_CvSURFPoint_class();

    register_CvSVMParams_class();

    register_CvSVM_class();

    register_CvSeq_class();

    register_CvSeqBlock_class();

    register_CvSeqReader_class();

    register_CvSeqWriter_class();

    register_CvSet_class();

    register_CvSetElem_class();

    register_CvStarDetectorParams_class();

    register_CvStarKeypoint_class();

    register_CvStereoGCState_class();

    register_CvString_class();

    register_CvStringHashNode_class();

    register_CvSubdiv2D_class();

    register_CvSubdiv2DPoint_class();

    register_CvTreeNodeIterator_class();

    register_CvType_class();

    register_CvTypeInfo_class();

    register_CvVectors_class();

    register_CvContourScanner_class();

    register_Size2i_class();

    register_CascadeClassifier_class();

    register_Complexd_class();

    register_Complexf_class();

    register_FeatureEvaluator_class();

    register_PatchGenerator_class();

    register_FernClassifier_class();

    register_FileNode_class();

    bp::implicitly_convertible< cv::FileNode, std::string >();

    bp::implicitly_convertible< cv::FileNode, double >();

    bp::implicitly_convertible< cv::FileNode, float >();

    bp::implicitly_convertible< cv::FileNode, int >();

    register_FileStorage_class();

    register_Point2i_class();

    bp::implicitly_convertible< cv::Point_< int >, cv::Vec< int, 2 > >();

    register_Rect_class();

    register_Vec4d_class();

    register_Scalar_class();

    register_FilterEngine_class();

    register_HOGDescriptor_class();

    register_KDTree_class();

    register_KalmanFilter_class();

    register_KeyPoint_class();

    register_LDetector_class();

    register_TermCriteria_class();

    bp::implicitly_convertible< cv::TermCriteria, CvTermCriteria >();

    register_LevMarqSparse_class();

    register_LineIterator_class();

    register_MSER_class();

    register_MatND_class();

    bp::implicitly_convertible< cv::MatND, cv::Mat >();

    register_Mesh3D_class();

    register_Moments_class();

    register_NAryMatNDIterator_class();

    register_Octree_class();

    register_OneWayDescriptor_class();

    register_OneWayDescriptorBase_class();

    register_OneWayDescriptorObject_class();

    register_PCA_class();

    register_PlanarObjectDetector_class();

    register_Point3d_class();

    bp::implicitly_convertible< cv::Point3_< double >, cv::Vec< double, 3 > >();

    register_Point3f_class();

    bp::implicitly_convertible< cv::Point3_< float >, cv::Vec< float, 3 > >();

    register_Point3i_class();

    bp::implicitly_convertible< cv::Point3_< int >, cv::Vec< int, 3 > >();

    register_Point2d_class();

    bp::implicitly_convertible< cv::Point_< double >, cv::Vec< double, 2 > >();

    register_Point2f_class();

    bp::implicitly_convertible< cv::Point_< float >, cv::Vec< float, 2 > >();

    register_Ptr_CvFileStorage_class();

    register_Ptr_CvHaarClassifierCascade_class();

    register_Ptr_CvStereoBMState_class();

    register_Ptr_BaseColumnFilter_class();

    register_Ptr_BaseFilter_class();

    register_Ptr_BaseRowFilter_class();

    register_Ptr_FeatureEvaluator_class();

    register_Ptr_FilterEngine_class();

    register_RNG_class();

    bp::implicitly_convertible< cv::RNG, schar >();

    bp::implicitly_convertible< cv::RNG, uchar >();

    bp::implicitly_convertible< cv::RNG, ushort >();

    bp::implicitly_convertible< cv::RNG, double >();

    bp::implicitly_convertible< cv::RNG, float >();

    bp::implicitly_convertible< cv::RNG, int >();

    bp::implicitly_convertible< cv::RNG, short int >();

    bp::implicitly_convertible< cv::RNG, unsigned int >();

    register_Range_class();

    bp::implicitly_convertible< cv::Range, CvSlice >();

    register_Rectd_class();

    register_Rectf_class();

    register_RotatedRect_class();

    register_SURF_class();

    register_SVD_class();

    register_SelfSimDescriptor_class();

    register_Size2d_class();

    register_Size2f_class();

    register_SparseMat_class();

    register_SparseMatConstIterator_class();

    register_SparseMatIterator_class();

    register_SpinImageModel_class();

    register_StarDetector_class();

    register_StereoBM_class();

    register_TickMeter_class();

    register_Vec2d_class();

    register_Vec3d_class();

    register_Vec6d_class();

    register_Vec2f_class();

    register_Vec3f_class();

    register_Vec4f_class();

    register_Vec6f_class();

    register_Vec2i_class();

    register_Vec3i_class();

    register_Vec4i_class();

    register_Vec2s_class();

    register_Vec3s_class();

    register_Vec4s_class();

    register_Vec2b_class();

    register_Vec3b_class();

    register_Vec4b_class();

    register_Vec2w_class();

    register_Vec3w_class();

    register_Vec4w_class();

    register_VideoCapture_class();

    register_VideoWriter_class();

    register_AutotunedIndexParams_class();

    register_CompositeIndexParams_class();

    register_Index_class();

    register_KDTreeIndexParams_class();

    register_KMeansIndexParams_class();

    register_LinearIndexParams_class();

    register_SavedIndexParams_class();

    register_SearchParams_class();

    register_flann_Index_class();

    register_lsh_hash_class();

    { //::cv::FAST
    
        typedef boost::python::object ( *FAST_function_type )( ::cv::Mat const &,int,bool );
        
        bp::def( 
            "FAST"
            , FAST_function_type( &FAST_23d17220884e2f371691b185394322ec )
            , ( bp::arg("image"), bp::arg("threshold"), bp::arg("nonmax_supression")=(bool)(true) ) );
    
    }

    { //::cv::HoughCircles
    
        typedef boost::python::object ( *HoughCircles_function_type )( ::cv::Mat const &,int,double,double,double,double,int,int );
        
        bp::def( 
            "HoughCircles"
            , HoughCircles_function_type( &HoughCircles_ea2999473356200d9d2fc8b7258555b0 )
            , ( bp::arg("image"), bp::arg("method"), bp::arg("dp"), bp::arg("minDist"), bp::arg("param1")=100, bp::arg("param2")=100, bp::arg("minRadius")=(int)(0), bp::arg("maxRadius")=(int)(0) ) );
    
    }

    { //::cv::HoughLines
    
        typedef boost::python::object ( *HoughLines_function_type )( ::cv::Mat const &,double,double,int,double,double );
        
        bp::def( 
            "HoughLines"
            , HoughLines_function_type( &HoughLines_deaa796a20e753a0b781de4a4d81ba3d )
            , ( bp::arg("image"), bp::arg("rho"), bp::arg("theta"), bp::arg("threshold"), bp::arg("srn")=0, bp::arg("stn")=0 ) );
    
    }

    { //::cv::HoughLinesP
    
        typedef boost::python::object ( *HoughLinesP_function_type )( ::cv::Mat &,double,double,int,double,double );
        
        bp::def( 
            "HoughLinesP"
            , HoughLinesP_function_type( &HoughLinesP_7e83e90590dfee49ad9ee8d704d1cfcb )
            , ( bp::arg("image"), bp::arg("rho"), bp::arg("theta"), bp::arg("threshold"), bp::arg("minLineLength")=0, bp::arg("maxLineGap")=0 ) );
    
    }

    { //::cv::HuMoments
    
        typedef boost::python::object ( *HuMoments_function_type )( ::cv::Moments const & );
        
        bp::def( 
            "HuMoments"
            , HuMoments_function_type( &HuMoments_646f4ee3824db566d9124eee2bb204ab )
            , ( bp::arg("moments") ) );
    
    }

    { //::cv::buildPyramid
    
        typedef boost::python::object ( *buildPyramid_function_type )( ::cv::Mat const &,int );
        
        bp::def( 
            "buildPyramid"
            , buildPyramid_function_type( &buildPyramid_84cd4ffd24fbd4dbaeccf86ceb1007ac )
            , ( bp::arg("src"), bp::arg("maxlevel") ) );
    
    }

    { //::cv::calcCovarMatrix
    
        typedef void ( *calcCovarMatrix_function_type )( boost::python::object,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "calcCovarMatrix"
            , calcCovarMatrix_function_type( &calcCovarMatrix_e8cf288956f6478b98045989198e81f5 )
            , ( bp::arg("samples"), bp::arg("covar"), bp::arg("mean"), bp::arg("flags"), bp::arg("ctype")=(int)(6) ) );
    
    }

    { //::cv::calcOpticalFlowPyrLK
    
        typedef boost::python::tuple ( *calcOpticalFlowPyrLK_function_type )( ::cv::Mat const &,::cv::Mat const &,bp::tuple,::cv::Size,int,::cv::TermCriteria,double,int );
        
        bp::def( 
            "calcOpticalFlowPyrLK"
            , calcOpticalFlowPyrLK_function_type( &calcOpticalFlowPyrLK_2855d31de3545ba96e3fc0ad950740f1 )
            , ( bp::arg("prevImg"), bp::arg("nextImg"), bp::arg("prevPts"), bp::arg("winSize")=cv::Size_<int>(15, 15), bp::arg("maxLevel")=(int)(3), bp::arg("criteria")=cv::TermCriteria(3, 30, 1.0000000000000000208166817117216851329430937767e-2), bp::arg("derivLambda")=5.0e-1, bp::arg("flags")=(int)(0) ) );
    
    }

    { //::cv::calibrateCamera
    
        typedef boost::python::tuple ( *calibrateCamera_function_type )( bp::tuple,bp::tuple,::cv::Size,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "calibrateCamera"
            , calibrateCamera_function_type( &calibrateCamera_e3c243276629b1246626096d8ff70485 )
            , ( bp::arg("objectPoints"), bp::arg("imagePoints"), bp::arg("imageSize"), bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("flags")=(int)(0) ) );
    
    }

    { //::cv::checkRange
    
        typedef boost::python::tuple ( *checkRange_function_type )( ::cv::MatND const &,bool,double,double );
        
        bp::def( 
            "checkRange"
            , checkRange_function_type( &checkRange_138f1b60b28a059182d9f09088ca2474 )
            , ( bp::arg("a"), bp::arg("quiet")=(bool)(true), bp::arg("minVal")=-1.79769313486231570814527423731704356798070567526e+308, bp::arg("maxVal")=1.79769313486231570814527423731704356798070567526e+308 ) );
    
    }

    { //::cv::checkRange
    
        typedef boost::python::tuple ( *checkRange_function_type )( ::cv::Mat const &,bool,double,double );
        
        bp::def( 
            "checkRange"
            , checkRange_function_type( &checkRange_31cc45f75977959e58047954bd730b32 )
            , ( bp::arg("a"), bp::arg("quiet")=(bool)(true), bp::arg("minVal")=-1.79769313486231570814527423731704356798070567526e+308, bp::arg("maxVal")=1.79769313486231570814527423731704356798070567526e+308 ) );
    
    }

    { //::cv::computeCorrespondEpilines
    
        typedef boost::python::object ( *computeCorrespondEpilines_function_type )( ::cv::Mat const &,int,::cv::Mat const & );
        
        bp::def( 
            "computeCorrespondEpilines"
            , computeCorrespondEpilines_function_type( &computeCorrespondEpilines_c5fa9f4742dac0ce300bb37345eb1f07 )
            , ( bp::arg("points1"), bp::arg("whichImage"), bp::arg("F") ) );
    
    }

    { //::cv::convertPointsHomogeneous
    
        typedef boost::python::object ( *convertPointsHomogeneous2D_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "convertPointsHomogeneous2D"
            , convertPointsHomogeneous2D_function_type( &convertPointsHomogeneous_a80a768ed55e897cac15946457cd1696 )
            , ( bp::arg("src") ) );
    
    }

    { //::cv::convertPointsHomogeneous
    
        typedef boost::python::object ( *convertPointsHomogeneous3D_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "convertPointsHomogeneous3D"
            , convertPointsHomogeneous3D_function_type( &convertPointsHomogeneous_d220e3269e8c59fdb5b2dc2f830579b0 )
            , ( bp::arg("src") ) );
    
    }

    { //::cv::convexHull
    
        typedef boost::python::object ( *convexHullIdx_function_type )( ::cv::Mat const &,bool );
        
        bp::def( 
            "convexHullIdx"
            , convexHullIdx_function_type( &convexHull_a7bf196b869588f11c69529c43975a42 )
            , ( bp::arg("points"), bp::arg("clockwise")=(bool)(false) ) );
    
    }

    { //::cv::cornerSubPix
    
        typedef boost::python::object ( *cornerSubPix_function_type )( ::cv::Mat const &,bp::tuple,::cv::Size,::cv::Size,::cv::TermCriteria );
        
        bp::def( 
            "cornerSubPix"
            , cornerSubPix_function_type( &cornerSubPix_897410ee39f221d5b382cc794de38b84 )
            , ( bp::arg("image"), bp::arg("corners"), bp::arg("winSize"), bp::arg("zeroZone"), bp::arg("criteria") ) );
    
    }

    { //::cvAcc
    
        typedef void ( *acc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "acc"
            , acc_function_type( &cvAcc_ef7ed9735ac6fce4129e5e89f645482d )
            , ( bp::arg("image"), bp::arg("sum"), bp::arg("mask")=cv::Mat() ) );
    
    }

    { //::cvCalcAffineFlowPyrLK
    
        typedef boost::python::tuple ( *calcAffineFlowPyrLK_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,boost::python::object,::CvSize,int,::CvTermCriteria,int );
        
        bp::def( 
            "calcAffineFlowPyrLK"
            , calcAffineFlowPyrLK_function_type( &cvCalcAffineFlowPyrLK_3a4b3f5dff85e72a121da3f42cded4aa )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("prev_pyr"), bp::arg("curr_pyr"), bp::arg("prev_features"), bp::arg("win_size"), bp::arg("level"), bp::arg("criteria"), bp::arg("flags") ) );
    
    }

    { //::cvCalcArrBackProject
    
        typedef void ( *calcArrBackProject_function_type )( boost::python::object,::cv::Mat &,::CvHistogram const * );
        
        bp::def( 
            "calcArrBackProject"
            , calcArrBackProject_function_type( &cvCalcArrBackProject_5961923bfd62f49a1a0aa6e73fd2cee6 )
            , ( bp::arg("image"), bp::arg("dst"), bp::arg("hist") ) );
    
    }

    { //::cvCalcArrBackProjectPatch
    
        typedef void ( *calcArrBackProjectPatch_function_type )( boost::python::object,::cv::Mat &,::CvSize,::CvHistogram *,int,double );
        
        bp::def( 
            "calcArrBackProjectPatch"
            , calcArrBackProjectPatch_function_type( &cvCalcArrBackProjectPatch_5574debe9c7d943baa020075e0434b56 )
            , ( bp::arg("image"), bp::arg("dst"), bp::arg("range"), bp::arg("hist"), bp::arg("method"), bp::arg("factor") ) );
    
    }

    { //::cvCalcArrHist
    
        typedef void ( *calcArrHist_function_type )( boost::python::object,::CvHistogram *,int,::cv::Mat );
        
        bp::def( 
            "calcArrHist"
            , calcArrHist_function_type( &cvCalcArrHist_1919ae68601cfdffd256e40ac0fbe86e )
            , ( bp::arg("arr"), bp::arg("hist"), bp::arg("accumulate")=(int)(0), bp::arg("mask")=cv::Mat() ) );
    
    }

    { //::cvCalcBayesianProb
    
        typedef void ( *calcBayesianProb_function_type )( boost::python::object,boost::python::object );
        
        bp::def( 
            "calcBayesianProb"
            , calcBayesianProb_function_type( &cvCalcBayesianProb_1195a20f1f016c88866792b21372e3f9 )
            , ( bp::arg("src"), bp::arg("dst") ) );
    
    }

    { //::cvCalcEMD2
    
        typedef boost::python::object ( *calcEMD2_function_type )( ::cv::Mat &,::cv::Mat &,int,boost::python::object,::cv::Mat,::cv::Mat,float *,boost::python::object );
        
        bp::def( 
            "calcEMD2"
            , calcEMD2_function_type( &cvCalcEMD2_f4e5308a9258b3a75a06fb112d06a2e8 )
            , ( bp::arg("signature1"), bp::arg("signature2"), bp::arg("distance_type"), bp::arg("distance_func")=bp::object(), bp::arg("cost_matrix")=cv::Mat(), bp::arg("flow")=cv::Mat(), bp::arg("lower_bound")=bp::object(), bp::arg("userdata")=bp::object() ) );
    
    }

    { //::cvCalcGlobalOrientation
    
        typedef boost::python::object ( *calcGlobalOrientation_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,double );
        
        bp::def( 
            "calcGlobalOrientation"
            , calcGlobalOrientation_function_type( &cvCalcGlobalOrientation_9d75a586d5a67c41e4450ccf9b8af7b3 )
            , ( bp::arg("orientation"), bp::arg("mask"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") ) );
    
    }

    { //::cvCalcHist
    
        typedef void ( *calcHist_function_type )( boost::python::object,::CvHistogram *,int,::cv::Mat );
        
        bp::def( 
            "calcHist"
            , calcHist_function_type( &cvCalcHist_419724e5b83c7c4f7e5371b8d787f899 )
            , ( bp::arg("image"), bp::arg("hist"), bp::arg("accumulate")=(int)(0), bp::arg("mask")=cv::Mat() ) );
    
    }

    { //::cvCalcImageHomography
    
        typedef boost::python::object ( *calcImageHomography_function_type )( boost::python::object,::CvPoint3D32f *,boost::python::object );
        
        bp::def( 
            "calcImageHomography"
            , calcImageHomography_function_type( &cvCalcImageHomography_a814cf819bbf03a0c8d0b4fd1b700335 )
            , ( bp::arg("line"), bp::arg("center"), bp::arg("intrinsic") ) );
    
    }

    { //::cvCalcMotionGradient
    
        typedef void ( *calcMotionGradient_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,double,double,int );
        
        bp::def( 
            "calcMotionGradient"
            , calcMotionGradient_function_type( &cvCalcMotionGradient_7506fb6ca34b4a6cb9165f5aff081454 )
            , ( bp::arg("mhi"), bp::arg("mask"), bp::arg("orientation"), bp::arg("delta1"), bp::arg("delta2"), bp::arg("aperture_size")=(int)(3) ) );
    
    }

    { //::cvCalcOpticalFlowBM
    
        typedef void ( *calcOpticalFlowBM_function_type )( ::cv::Mat &,::cv::Mat &,::CvSize,::CvSize,::CvSize,int,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "calcOpticalFlowBM"
            , calcOpticalFlowBM_function_type( &cvCalcOpticalFlowBM_3537c5574d176e4f3dea85450be5ee9f )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("block_size"), bp::arg("shift_size"), bp::arg("max_range"), bp::arg("use_previous"), bp::arg("velx"), bp::arg("vely") ) );
    
    }

    { //::cvCalcOpticalFlowHS
    
        typedef void ( *calcOpticalFlowHS_function_type )( ::cv::Mat &,::cv::Mat &,int,::cv::Mat &,::cv::Mat &,double,::CvTermCriteria );
        
        bp::def( 
            "calcOpticalFlowHS"
            , calcOpticalFlowHS_function_type( &cvCalcOpticalFlowHS_0757feb4eeb7fd8c38b710aec2f5f8e9 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("use_previous"), bp::arg("velx"), bp::arg("vely"), bp::arg("lambda"), bp::arg("criteria") ) );
    
    }

    { //::cvCalcOpticalFlowLK
    
        typedef void ( *calcOpticalFlowLK_function_type )( ::cv::Mat &,::cv::Mat &,::CvSize,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "calcOpticalFlowLK"
            , calcOpticalFlowLK_function_type( &cvCalcOpticalFlowLK_0539268816232dbc93df209c0dc87327 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("win_size"), bp::arg("velx"), bp::arg("vely") ) );
    
    }

    { //::cvCalcOpticalFlowPyrLK
    
        typedef boost::python::tuple ( *calcOpticalFlowPyrLK_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,boost::python::object,::CvSize,int,::CvTermCriteria,int );
        
        bp::def( 
            "calcOpticalFlowPyrLK"
            , calcOpticalFlowPyrLK_function_type( &cvCalcOpticalFlowPyrLK_925fd4448f97740474886f84b12836c2 )
            , ( bp::arg("prev"), bp::arg("curr"), bp::arg("prev_pyr"), bp::arg("curr_pyr"), bp::arg("prev_features"), bp::arg("win_size"), bp::arg("level"), bp::arg("criteria"), bp::arg("flags") ) );
    
    }

    { //::cvConDensInitSampleSet
    
        typedef void ( *conDensInitSampleSet_function_type )( ::CvConDensation *,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "conDensInitSampleSet"
            , conDensInitSampleSet_function_type( &cvConDensInitSampleSet_2b2c9d04e9f57fb36a248c795590341d )
            , ( bp::arg("condens"), bp::arg("lower_bound"), bp::arg("upper_bound") ) );
    
    }

    { //::cvConvertImage
    
        typedef void ( *convertImage_function_type )( ::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "convertImage"
            , convertImage_function_type( &cvConvertImage_9d5028440635df77832885475bf0ea00 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("flags")=(int)(0) ) );
    
    }

    { //::cvConvexityDefects
    
        typedef boost::python::object ( *convexityDefects_function_type )( ::cv::Mat &,::cv::Mat &,::CvMemStorage * );
        
        bp::def( 
            "convexityDefects"
            , convexityDefects_function_type( &cvConvexityDefects_cc97bf52cc42e365950605a23b42e95a )
            , ( bp::arg("contour"), bp::arg("convexhull"), bp::arg("storage")=bp::object() ) );
    
    }

    { //::cvCopyHist
    
        typedef boost::python::object ( *copyHist_function_type )( ::CvHistogram const * );
        
        bp::def( 
            "copyHist"
            , copyHist_function_type( &cvCopyHist_b2f53bbcb5a66f34f5710634d38c376f )
            , ( bp::arg("src") ) );
    
    }

    { //::cvCorrectMatches
    
        typedef void ( *correctMatches_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "correctMatches"
            , correctMatches_function_type( &cvCorrectMatches_055faac2f695cea7fa86e829ba6bdc99 )
            , ( bp::arg("F"), bp::arg("points1"), bp::arg("points2"), bp::arg("new_points1"), bp::arg("new_points2") ) );
    
    }

    { //::cvCreateHist
    
        typedef boost::python::object ( *createHist_function_type )( boost::python::object,int,boost::python::object,int );
        
        bp::def( 
            "createHist"
            , createHist_function_type( &cvCreateHist_f2b39da376344404265809e761a6aaba )
            , ( bp::arg("sizes"), bp::arg("type"), bp::arg("ranges")=bp::object(), bp::arg("uniform")=(int)(1) ) );
    
    }

    { //::cvCreateKDTree
    
        typedef boost::python::object ( *createKDTree_function_type )( ::cv::Mat & );
        
        bp::def( 
            "createKDTree"
            , createKDTree_function_type( &cvCreateKDTree_bedd697814f42b0adb235e1d1bda9bdd )
            , ( bp::arg("desc") ) );
    
    }

    { //::cvCreateSpillTree
    
        typedef boost::python::object ( *createSpillTree_function_type )( ::cv::Mat &,int const,double const,double const );
        
        bp::def( 
            "createSpillTree"
            , createSpillTree_function_type( &cvCreateSpillTree_22146c3478f3d8c8ff22213a86f1b244 )
            , ( bp::arg("raw_data"), bp::arg("naive")=(int const)(50), bp::arg("rho")=6.99999999999999955591079014993738383054733276367e-1, bp::arg("tau")=1.00000000000000005551115123125782702118158340454e-1 ) );
    
    }

    { //::cvCreateTrackbar2
    
        typedef boost::python::tuple ( *_cvCreateTrackbar2_function_type )( char const *,char const *,unsigned int,int,boost::python::object,boost::python::object );
        
        bp::def( 
            "_cvCreateTrackbar2"
            , _cvCreateTrackbar2_function_type( &cvCreateTrackbar2_c093a5d4e70019414d270b02dacaafb5 )
            , ( bp::arg("trackbar_name"), bp::arg("window_name"), bp::arg("value"), bp::arg("count"), bp::arg("on_change"), bp::arg("userdata")=bp::object() ) );
    
    }

    { //::cvDistTransform
    
        typedef void ( *distTransform_function_type )( ::cv::Mat &,::cv::Mat &,int,int,boost::python::object,::cv::Mat );
        
        bp::def( 
            "distTransform"
            , distTransform_function_type( &cvDistTransform_68addecae85b6b48cd46044102a6c028 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("distance_type")=(int)(2), bp::arg("mask_size")=(int)(3), bp::arg("mask")=bp::object(), bp::arg("labels")=cv::Mat() ) );
    
    }

    { //::cvEndWriteStruct
    
        typedef void ( *endWriteStruct_function_type )( ::cv::FileStorage & );
        
        bp::def( 
            "endWriteStruct"
            , endWriteStruct_function_type( &cvEndWriteStruct_49df8f8a99539026dfbd302575d7a485 )
            , ( bp::arg("fs") ) );
    
    }

    { //::cvEqualizeHist
    
        typedef void ( *equalizeHist_function_type )( ::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "equalizeHist"
            , equalizeHist_function_type( &cvEqualizeHist_02ceca177f2ff14473c32e524cb68017 )
            , ( bp::arg("src"), bp::arg("dst") ) );
    
    }

    { //::cvEstimateRigidTransform
    
        typedef boost::python::object ( *estimateRigidTransform_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "estimateRigidTransform"
            , estimateRigidTransform_function_type( &cvEstimateRigidTransform_2f885814bd847b94c8621a570a36abad )
            , ( bp::arg("A"), bp::arg("B"), bp::arg("M"), bp::arg("full_affine") ) );
    
    }

    { //::cvFindFeatures
    
        typedef void ( *findFeatures_function_type )( ::CvFeatureTree *,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "findFeatures"
            , findFeatures_function_type( &cvFindFeatures_3cdcd7c246944a80a295b6f20e448cfc )
            , ( bp::arg("tr"), bp::arg("query_points"), bp::arg("indices"), bp::arg("dist"), bp::arg("k"), bp::arg("emax")=(int)(20) ) );
    
    }

    { //::cvFindFeaturesBoxed
    
        typedef boost::python::object ( *findFeaturesBoxed_function_type )( ::CvFeatureTree *,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "findFeaturesBoxed"
            , findFeaturesBoxed_function_type( &cvFindFeaturesBoxed_6d675cd8257b64f665600bd276900d3e )
            , ( bp::arg("tr"), bp::arg("bounds_min"), bp::arg("bounds_max"), bp::arg("out_indices") ) );
    
    }

    { //::cvFindNearestPoint2D
    
        typedef boost::python::object ( *findNearestPoint2D_function_type )( ::CvSubdiv2D *,const ::cv::Point2f & );
        
        bp::def( 
            "findNearestPoint2D"
            , findNearestPoint2D_function_type( &cvFindNearestPoint2D_4658231361f43a6fc66c2e150f75dca8 )
            , ( bp::arg("subdiv"), bp::arg("pt") ) );
    
    }

    { //::cvFindStereoCorrespondenceGC
    
        typedef void ( *findStereoCorrespondenceGC_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::CvStereoGCState *,int );
        
        bp::def( 
            "findStereoCorrespondenceGC"
            , findStereoCorrespondenceGC_function_type( &cvFindStereoCorrespondenceGC_c3eefaed321a780e7059f7c3392c4672 )
            , ( bp::arg("left"), bp::arg("right"), bp::arg("disparityLeft"), bp::arg("disparityRight"), bp::arg("state"), bp::arg("useDisparityGuess")=(int)(0) ) );
    
    }

    { //::cvGetElemType
    
        typedef boost::python::object ( *getElemType_function_type )( ::cv::Mat & );
        
        bp::def( 
            "getElemType"
            , getElemType_function_type( &cvGetElemType_28303ccd15acadc45a20b8189b3b5941 )
            , ( bp::arg("arr") ) );
    
    }

    { //::cvGetFileNode
    
        typedef boost::python::object ( *getFileNode_function_type )( ::cv::FileStorage &,::cv::FileNode &,::CvStringHashNode const *,int );
        
        bp::def( 
            "getFileNode"
            , getFileNode_function_type( &cvGetFileNode_6a2476df18b42d117da27c3c0b8b7c10 )
            , ( bp::arg("fs"), bp::arg("map"), bp::arg("key"), bp::arg("create_missing")=(int)(0) ) );
    
    }

    { //::cvGetFileNodeByName
    
        typedef boost::python::object ( *getFileNodeByName_function_type )( ::CvFileStorage const *,::cv::FileNode const &,char const * );
        
        bp::def( 
            "getFileNodeByName"
            , getFileNodeByName_function_type( &cvGetFileNodeByName_061e25a343ad5bb2f02da02bf45be998 )
            , ( bp::arg("fs"), bp::arg("map"), bp::arg("name") ) );
    
    }

    { //::cvGetFileNodeName
    
        typedef boost::python::object ( *getFileNodeName_function_type )( ::cv::FileNode const & );
        
        bp::def( 
            "getFileNodeName"
            , getFileNodeName_function_type( &cvGetFileNodeName_dad254a89ba86caf1ba5012875e2fb32 )
            , ( bp::arg("node") ) );
    
    }

    { //::cvGetHashedKey
    
        typedef boost::python::object ( *getHashedKey_function_type )( ::cv::FileStorage &,char const *,int,int );
        
        bp::def( 
            "getHashedKey"
            , getHashedKey_function_type( &cvGetHashedKey_5bf3bb09f908d63c5767d651120f813f )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("len")=(int)(-0x000000001), bp::arg("create_missing")=(int)(0) ) );
    
    }

    { //::cvGetMinMaxHistValue
    
        typedef void ( *_cvGetMinMaxHistValue_function_type )( ::CvHistogram const *,unsigned int,unsigned int,unsigned int,unsigned int );
        
        bp::def( 
            "_cvGetMinMaxHistValue"
            , _cvGetMinMaxHistValue_function_type( &cvGetMinMaxHistValue_a31aae680af640edcfcb77bf873f90f6 )
            , ( bp::arg("hist"), bp::arg("min_value"), bp::arg("max_value"), bp::arg("min_idx")=(unsigned int)(0), bp::arg("max_idx")=(unsigned int)(0) ) );
    
    }

    { //::cvGetQuadrangleSubPix
    
        typedef void ( *getQuadrangleSubPix_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "getQuadrangleSubPix"
            , getQuadrangleSubPix_function_type( &cvGetQuadrangleSubPix_fe2b1a5028fa8b02301dc960cdfbc131 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("map_matrix") ) );
    
    }

    { //::cvInitNArrayIterator
    
        typedef boost::python::object ( *initNArrayIterator_function_type )( boost::python::object,::cv::Mat &,::CvMatND *,::CvNArrayIterator *,int );
        
        bp::def( 
            "initNArrayIterator"
            , initNArrayIterator_function_type( &cvInitNArrayIterator_4c1924434c279d42b088754762acc53b )
            , ( bp::arg("arrs"), bp::arg("mask"), bp::arg("stubs"), bp::arg("array_iterator"), bp::arg("flags")=(int)(0) ) );
    
    }

    { //::cvInitSystem
    
        typedef boost::python::object ( *initSystem_function_type )( boost::python::object );
        
        bp::def( 
            "initSystem"
            , initSystem_function_type( &cvInitSystem_f0aa383f9ae0b2f0bf89bbcb5e73da23 )
            , ( bp::arg("argv") ) );
    
    }

    { //::cvLSHAdd
    
        typedef void ( *LSHAdd_function_type )( ::CvLSH *,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "LSHAdd"
            , LSHAdd_function_type( &cvLSHAdd_fead3e6b36de0b14c88ef1b561c6e621 )
            , ( bp::arg("lsh"), bp::arg("data"), bp::arg("indices")=cv::Mat() ) );
    
    }

    { //::cvLSHQuery
    
        typedef void ( *LSHQuery_function_type )( ::CvLSH *,::cv::Mat &,::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "LSHQuery"
            , LSHQuery_function_type( &cvLSHQuery_a5f47e360cc9701a6672c12490153852 )
            , ( bp::arg("lsh"), bp::arg("query_points"), bp::arg("indices"), bp::arg("dist"), bp::arg("k"), bp::arg("emax") ) );
    
    }

    { //::cvLSHRemove
    
        typedef void ( *LSHRemove_function_type )( ::CvLSH *,::cv::Mat & );
        
        bp::def( 
            "LSHRemove"
            , LSHRemove_function_type( &cvLSHRemove_5f32fb503216c52038c4ae3bf17b62db )
            , ( bp::arg("lsh"), bp::arg("indices") ) );
    
    }

    { //::cvLinearPolar
    
        typedef void ( *linearPolar_function_type )( ::cv::Mat &,::cv::Mat &,const ::cv::Point2f &,double,int );
        
        bp::def( 
            "linearPolar"
            , linearPolar_function_type( &cvLinearPolar_b75d44697de3c90f0462366e93d77425 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("center"), bp::arg("maxRadius"), bp::arg("flags")=(int)(9) ) );
    
    }

    { //::cvLogPolar
    
        typedef void ( *logPolar_function_type )( ::cv::Mat &,::cv::Mat &,const ::cv::Point2f &,double,int );
        
        bp::def( 
            "logPolar"
            , logPolar_function_type( &cvLogPolar_27c4d18226a6e750886777db97773f4d )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("center"), bp::arg("M"), bp::arg("flags")=(int)(9) ) );
    
    }

    { //::cvMultiplyAcc
    
        typedef void ( *multiplyAcc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "multiplyAcc"
            , multiplyAcc_function_type( &cvMultiplyAcc_c64c83fc39cb1265f3d1a69d9e600a47 )
            , ( bp::arg("image1"), bp::arg("image2"), bp::arg("acc"), bp::arg("mask")=cv::Mat() ) );
    
    }

    { //::cvPointSeqFromMat
    
        typedef boost::python::object ( *pointSeqFromMat_function_type )( int,::cv::Mat &,::CvContour *,::CvSeqBlock * );
        
        bp::def( 
            "pointSeqFromMat"
            , pointSeqFromMat_function_type( &cvPointSeqFromMat_ef8459cfef37d715411cf088e0da5576 )
            , ( bp::arg("seq_kind"), bp::arg("mat"), bp::arg("contour_header"), bp::arg("block") ) );
    
    }

    { //::cvPyrMeanShiftFiltering
    
        typedef void ( *pyrMeanShiftFiltering_function_type )( ::cv::Mat &,::cv::Mat &,double,double,int,::CvTermCriteria );
        
        bp::def( 
            "pyrMeanShiftFiltering"
            , pyrMeanShiftFiltering_function_type( &cvPyrMeanShiftFiltering_21ec6b7149a6e00a31f1d76aebb9a22b )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("sp"), bp::arg("sr"), bp::arg("max_level")=(int)(1), bp::arg("termcrit")=cv::TermCriteria(3, 5, 1.0e+0) ) );
    
    }

    { //::cvPyrSegmentation
    
        typedef boost::python::object ( *pyrSegmentation_function_type )( ::cv::Mat &,::cv::Mat &,::CvMemStorage *,int,double,double );
        
        bp::def( 
            "pyrSegmentation"
            , pyrSegmentation_function_type( &cvPyrSegmentation_0a5e58f4641f1c9757bb83d3f16f4191 )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("storage"), bp::arg("level"), bp::arg("threshold1"), bp::arg("threshold2") ) );
    
    }

    { //::cvRandArr
    
        typedef void ( *randArr_function_type )( ::cv::RNG &,::cv::Mat &,int,::CvScalar,::CvScalar );
        
        bp::def( 
            "randArr"
            , randArr_function_type( &cvRandArr_7e6e03c94e3a5f654b62b47647889d1d )
            , ( bp::arg("rng"), bp::arg("arr"), bp::arg("dist_type"), bp::arg("param1"), bp::arg("param2") ) );
    
    }

    { //::cvRange
    
        typedef boost::python::object ( *range__function_type )( ::cv::Mat &,double,double );
        
        bp::def( 
            "range_"
            , range__function_type( &cvRange_073a997114e2c96bbeff2aaa986e76a1 )
            , ( bp::arg("mat"), bp::arg("start"), bp::arg("end") ) );
    
    }

    { //::cvReadInt
    
        typedef boost::python::object ( *readInt_function_type )( ::cv::FileNode const &,int );
        
        bp::def( 
            "readInt"
            , readInt_function_type( &cvReadInt_dca28f92c7fa1c5a899d9ab353ae882e )
            , ( bp::arg("node"), bp::arg("default_value")=(int)(0) ) );
    
    }

    { //::cvReadIntByName
    
        typedef boost::python::object ( *readIntByName_function_type )( ::CvFileStorage const *,::cv::FileNode const &,char const *,int );
        
        bp::def( 
            "readIntByName"
            , readIntByName_function_type( &cvReadIntByName_7241d5979fbc58c330d0adada9c3a3db )
            , ( bp::arg("fs"), bp::arg("map"), bp::arg("name"), bp::arg("default_value")=(int)(0) ) );
    
    }

    { //::cvReadReal
    
        typedef boost::python::object ( *readReal_function_type )( ::cv::FileNode const &,double );
        
        bp::def( 
            "readReal"
            , readReal_function_type( &cvReadReal_77fd0854d614bbd71a10b38d8f07166b )
            , ( bp::arg("node"), bp::arg("default_value")=0.0 ) );
    
    }

    { //::cvReadRealByName
    
        typedef boost::python::object ( *readRealByName_function_type )( ::CvFileStorage const *,::cv::FileNode const &,char const *,double );
        
        bp::def( 
            "readRealByName"
            , readRealByName_function_type( &cvReadRealByName_28cd8eea8cf4c8740bae8bb907fc7ea4 )
            , ( bp::arg("fs"), bp::arg("map"), bp::arg("name"), bp::arg("default_value")=0.0 ) );
    
    }

    { //::cvReadString
    
        typedef boost::python::object ( *readString_function_type )( ::cv::FileNode const &,char const * );
        
        bp::def( 
            "readString"
            , readString_function_type( &cvReadString_2d9e9aabc6de8c1b6e5e3284f1e79619 )
            , ( bp::arg("node"), bp::arg("default_value")=bp::object() ) );
    
    }

    { //::cvReadStringByName
    
        typedef boost::python::object ( *readStringByName_function_type )( ::CvFileStorage const *,::cv::FileNode const &,char const *,char const * );
        
        bp::def( 
            "readStringByName"
            , readStringByName_function_type( &cvReadStringByName_b4debf88a87b4914bb1fcab2b777cee6 )
            , ( bp::arg("fs"), bp::arg("map"), bp::arg("name"), bp::arg("default_value")=bp::object() ) );
    
    }

    { //::cvReleaseConDensation
    
        typedef void ( *_cvReleaseConDensation_function_type )( ::CvConDensation );
        
        bp::def( 
            "_cvReleaseConDensation"
            , _cvReleaseConDensation_function_type( &cvReleaseConDensation_f998e5f5422410bd74b2ba960fd05e2c )
            , ( bp::arg("condens") ) );
    
    }

    { //::cvReleaseFileStorage
    
        typedef void ( *_cvReleaseFileStorage_function_type )( ::CvFileStorage );
        
        bp::def( 
            "_cvReleaseFileStorage"
            , _cvReleaseFileStorage_function_type( &cvReleaseFileStorage_d53aa99c3241294fee03f3f038aa2bba )
            , ( bp::arg("fs") ) );
    
    }

    { //::cvReleaseMemStorage
    
        typedef void ( *_cvReleaseMemStorage_function_type )( ::CvMemStorage );
        
        bp::def( 
            "_cvReleaseMemStorage"
            , _cvReleaseMemStorage_function_type( &cvReleaseMemStorage_6ff4687a489093fb83fd38fb1d920837 )
            , ( bp::arg("storage") ) );
    
    }

    { //::cvReleasePOSITObject
    
        typedef void ( *_cvReleasePOSITObject_function_type )( ::CvPOSITObject );
        
        bp::def( 
            "_cvReleasePOSITObject"
            , _cvReleasePOSITObject_function_type( &cvReleasePOSITObject_679a5da1d4e28b86fdc9a28aa691c6ef )
            , ( bp::arg("posit_object") ) );
    
    }

    { //::cvReleaseStereoGCState
    
        typedef void ( *_cvReleaseStereoGCState_function_type )( ::CvStereoGCState );
        
        bp::def( 
            "_cvReleaseStereoGCState"
            , _cvReleaseStereoGCState_function_type( &cvReleaseStereoGCState_f9448f3f98670de75bac96972e1b9d45 )
            , ( bp::arg("state") ) );
    
    }

    { //::cvReprojectImageTo3D
    
        typedef void ( *reprojectImageTo3D_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,int );
        
        bp::def( 
            "reprojectImageTo3D"
            , reprojectImageTo3D_function_type( &cvReprojectImageTo3D_4ca87cd67ba33150d51d345f21a24447 )
            , ( bp::arg("disparityImage"), bp::arg("_3dImage"), bp::arg("Q"), bp::arg("handleMissingValues")=(int)(0) ) );
    
    }

    { //::cvRunningAvg
    
        typedef void ( *runningAvg_function_type )( ::cv::Mat &,::cv::Mat &,double,::cv::Mat );
        
        bp::def( 
            "runningAvg"
            , runningAvg_function_type( &cvRunningAvg_16515bd00db4472140aa21554e25bbc7 )
            , ( bp::arg("image"), bp::arg("acc"), bp::arg("alpha"), bp::arg("mask")=cv::Mat() ) );
    
    }

    { //::cvSURFPoint
    
        typedef boost::python::object ( *SURFPoint_function_type )( const ::cv::Point2f &,int,int,float,float );
        
        bp::def( 
            "SURFPoint"
            , SURFPoint_function_type( &cvSURFPoint_c0d89cc1fa2a754074aaa768acb95f48 )
            , ( bp::arg("pt"), bp::arg("laplacian"), bp::arg("size"), bp::arg("dir")=0, bp::arg("hessian")=0 ) );
    
    }

    { //::cvSampleLine
    
        typedef boost::python::object ( *sampleLine_function_type )( ::cv::Mat &,::CvPoint,::CvPoint,void *,int );
        
        bp::def( 
            "sampleLine"
            , sampleLine_function_type( &cvSampleLine_9eb7a74db955c3538aef5be3e7392fc5 )
            , ( bp::arg("image"), bp::arg("pt1"), bp::arg("pt2"), bp::arg("buffer"), bp::arg("connectivity")=(int)(8) ) );
    
    }

    { //::cvSegmentImage
    
        typedef boost::python::object ( *segmentImage_function_type )( ::cv::Mat &,::cv::Mat &,double,double,::CvMemStorage * );
        
        bp::def( 
            "segmentImage"
            , segmentImage_function_type( &cvSegmentImage_7b95313fd97ffe28d678124b5aa0a301 )
            , ( bp::arg("srcarr"), bp::arg("dstarr"), bp::arg("canny_threshold"), bp::arg("ffill_threshold"), bp::arg("storage") ) );
    
    }

    { //::cvSegmentMotion
    
        typedef boost::python::object ( *segmentMotion_function_type )( ::cv::Mat &,::cv::Mat &,::CvMemStorage *,double,double );
        
        bp::def( 
            "segmentMotion"
            , segmentMotion_function_type( &cvSegmentMotion_ed831c1d8f816ea759222aec4d41f1f0 )
            , ( bp::arg("mhi"), bp::arg("seg_mask"), bp::arg("storage"), bp::arg("timestamp"), bp::arg("seg_thresh") ) );
    
    }

    { //::cvSeqInsertSlice
    
        typedef void ( *seqInsertSlice_function_type )( ::CvSeq *,int,::cv::Mat & );
        
        bp::def( 
            "seqInsertSlice"
            , seqInsertSlice_function_type( &cvSeqInsertSlice_870f54253b0103a244c6ac596f2820c4 )
            , ( bp::arg("seq"), bp::arg("before_index"), bp::arg("from_arr") ) );
    
    }

    { //::cvSetHistBinRanges
    
        typedef void ( *setHistBinRanges_function_type )( ::CvHistogram *,boost::python::object,int );
        
        bp::def( 
            "setHistBinRanges"
            , setHistBinRanges_function_type( &cvSetHistBinRanges_09cb8cb8a16af84266aeebdf9d86df3f )
            , ( bp::arg("hist"), bp::arg("ranges"), bp::arg("uniform")=(int)(1) ) );
    
    }

    { //::cvSetMouseCallback
    
        typedef boost::python::object ( *_cvSetMouseCallback_function_type )( char const *,boost::python::object,boost::python::object );
        
        bp::def( 
            "_cvSetMouseCallback"
            , _cvSetMouseCallback_function_type( &cvSetMouseCallback_c212defec0903d7de57c5c0b0ee9b03d )
            , ( bp::arg("window_name"), bp::arg("on_mouse"), bp::arg("param")=bp::object() ) );
    
    }

    { //::cvSmooth
    
        typedef void ( *smooth_function_type )( ::cv::Mat &,::cv::Mat &,int,int,int,double,double );
        
        bp::def( 
            "smooth"
            , smooth_function_type( &cvSmooth_77e0c983f4273497b4a61c0a6dcda04f )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("smoothtype")=(int)(2), bp::arg("size1")=(int)(3), bp::arg("size2")=(int)(0), bp::arg("sigma1")=0, bp::arg("sigma2")=0 ) );
    
    }

    { //::cvSnakeImage
    
        typedef void ( *snakeImage_function_type )( ::cv::Mat &,::CvPoint *,int,boost::python::object,boost::python::object,boost::python::object,int,::CvSize,::CvTermCriteria,int );
        
        bp::def( 
            "snakeImage"
            , snakeImage_function_type( &cvSnakeImage_12c505f189b0be3fa57d4cc42c364735 )
            , ( bp::arg("image"), bp::arg("points"), bp::arg("length"), bp::arg("alpha"), bp::arg("beta"), bp::arg("gamma"), bp::arg("coeff_usage"), bp::arg("win"), bp::arg("criteria"), bp::arg("calc_gradient")=(int)(1) ) );
    
    }

    { //::cvSolveCubic
    
        typedef boost::python::object ( *solveCubic_function_type )( ::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "solveCubic"
            , solveCubic_function_type( &cvSolveCubic_97d0ac3b0fc6ba46cd5b5f2eaea79583 )
            , ( bp::arg("coeffs"), bp::arg("roots") ) );
    
    }

    { //::cvSolvePoly
    
        typedef void ( *solvePoly_function_type )( ::cv::Mat &,::cv::Mat &,int,int );
        
        bp::def( 
            "solvePoly"
            , solvePoly_function_type( &cvSolvePoly_a7fe4b7abe368e2e780716aa49dc8f82 )
            , ( bp::arg("coeffs"), bp::arg("roots2"), bp::arg("maxiter")=(int)(20), bp::arg("fig")=(int)(100) ) );
    
    }

    { //::cvSquareAcc
    
        typedef void ( *squareAcc_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat );
        
        bp::def( 
            "squareAcc"
            , squareAcc_function_type( &cvSquareAcc_df8ad076f822a2856ccecbbdf6a2b2b0 )
            , ( bp::arg("image"), bp::arg("sqsum"), bp::arg("mask")=cv::Mat() ) );
    
    }

    { //::cvStartFindContours
    
        typedef boost::python::object ( *startFindContours_function_type )( ::cv::Mat &,::CvMemStorage *,int,int,int,::CvPoint );
        
        bp::def( 
            "startFindContours"
            , startFindContours_function_type( &cvStartFindContours_1914ce1dccb0d5710ebdf49d4c3d96cc )
            , ( bp::arg("image"), bp::arg("storage"), bp::arg("header_size")=(int)(88u), bp::arg("mode")=(int)(1), bp::arg("method")=(int)(2), bp::arg("offset")=cv::Point(0, 0) ) );
    
    }

    { //::cvStartNextStream
    
        typedef void ( *startNextStream_function_type )( ::cv::FileStorage & );
        
        bp::def( 
            "startNextStream"
            , startNextStream_function_type( &cvStartNextStream_db71e53dfa9475145f4487a80d5d8bf2 )
            , ( bp::arg("fs") ) );
    
    }

    { //::cvStartReadRawData
    
        typedef void ( *startReadRawData_function_type )( ::CvFileStorage const *,::cv::FileNode const &,::CvSeqReader * );
        
        bp::def( 
            "startReadRawData"
            , startReadRawData_function_type( &cvStartReadRawData_4fe1fcc06b3f886cb6549cad64e1d1a0 )
            , ( bp::arg("fs"), bp::arg("src"), bp::arg("reader") ) );
    
    }

    { //::cvStartWriteStruct
    
        typedef void ( *startWriteStruct_function_type )( ::cv::FileStorage &,char const *,int,char const *,::CvAttrList );
        
        bp::def( 
            "startWriteStruct"
            , startWriteStruct_function_type( &cvStartWriteStruct_e7e2128639c3a858bdb332c89468a8e0 )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("struct_flags"), bp::arg("type_name")=bp::object(), bp::arg("attributes")=cvAttrList(0u, 0u) ) );
    
    }

    { //::cvSubdiv2DLocate
    
        typedef boost::python::tuple ( *subdiv2DLocate_function_type )( ::CvSubdiv2D *,const ::cv::Point2f &,::CvSubdiv2DEdge * );
        
        bp::def( 
            "subdiv2DLocate"
            , subdiv2DLocate_function_type( &cvSubdiv2DLocate_1df86dbc29fc9de6df2bbdb2196d6db3 )
            , ( bp::arg("subdiv"), bp::arg("pt"), bp::arg("edge") ) );
    
    }

    { //::cvSubdivDelaunay2DInsert
    
        typedef boost::python::object ( *subdivDelaunay2DInsert_function_type )( ::CvSubdiv2D *,const ::cv::Point2f & );
        
        bp::def( 
            "subdivDelaunay2DInsert"
            , subdivDelaunay2DInsert_function_type( &cvSubdivDelaunay2DInsert_0d66ff0b2bc8918d0793f968404f1cb2 )
            , ( bp::arg("subdiv"), bp::arg("pt") ) );
    
    }

    { //::cvTriangleArea
    
        typedef boost::python::object ( *triangleArea_function_type )( const ::cv::Point2f &,const ::cv::Point2f &,const ::cv::Point2f & );
        
        bp::def( 
            "triangleArea"
            , triangleArea_function_type( &cvTriangleArea_727599fdabcae9fb78274a766e9dac94 )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("c") ) );
    
    }

    { //::cvTriangulatePoints
    
        typedef void ( *triangulatePoints_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat & );
        
        bp::def( 
            "triangulatePoints"
            , triangulatePoints_function_type( &cvTriangulatePoints_eb948ff6300aa4ebf4fad0ec7d6d4e78 )
            , ( bp::arg("projMatr1"), bp::arg("projMatr2"), bp::arg("projPoints1"), bp::arg("projPoints2"), bp::arg("points4D") ) );
    
    }

    { //::cvTypeOf
    
        typedef boost::python::object ( *typeOf_function_type )( ::CvArr * );
        
        bp::def( 
            "typeOf"
            , typeOf_function_type( &cvTypeOf_4e7bd20b082b35b68253f04b04f578ce )
            , ( bp::arg("struct_ptr") ) );
    
    }

    { //::cvUpdateMotionHistory
    
        typedef void ( *updateMotionHistory_function_type )( ::cv::Mat &,::cv::Mat &,double,double );
        
        bp::def( 
            "updateMotionHistory"
            , updateMotionHistory_function_type( &cvUpdateMotionHistory_fb635b1eb55f77d94f46a70f41eac0b3 )
            , ( bp::arg("silhouette"), bp::arg("mhi"), bp::arg("timestamp"), bp::arg("duration") ) );
    
    }

    { //::cvWrite
    
        typedef void ( *write_function_type )( ::cv::FileStorage &,char const *,const char *,::CvAttrList );
        
        bp::def( 
            "write"
            , write_function_type( &cvWrite_00335cc764e72fb9408450c10fffab4a )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("ptr"), bp::arg("attributes")=cvAttrList(0u, 0u) ) );
    
    }

    { //::cvWriteComment
    
        typedef void ( *writeComment_function_type )( ::cv::FileStorage &,char const *,int );
        
        bp::def( 
            "writeComment"
            , writeComment_function_type( &cvWriteComment_3e89473031f5fbea0ed6232440721138 )
            , ( bp::arg("fs"), bp::arg("comment"), bp::arg("eol_comment") ) );
    
    }

    { //::cvWriteFileNode
    
        typedef void ( *writeFileNode_function_type )( ::cv::FileStorage &,char const *,::cv::FileNode const &,int );
        
        bp::def( 
            "writeFileNode"
            , writeFileNode_function_type( &cvWriteFileNode_4df1ea107367e738fdd6f88f15146fb9 )
            , ( bp::arg("fs"), bp::arg("new_node_name"), bp::arg("node"), bp::arg("embed") ) );
    
    }

    { //::cvWriteInt
    
        typedef void ( *writeInt_function_type )( ::cv::FileStorage &,char const *,int );
        
        bp::def( 
            "writeInt"
            , writeInt_function_type( &cvWriteInt_3ee9f31ea1735f25d28b6cfc1e87078a )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("value") ) );
    
    }

    { //::cvWriteReal
    
        typedef void ( *writeReal_function_type )( ::cv::FileStorage &,char const *,double );
        
        bp::def( 
            "writeReal"
            , writeReal_function_type( &cvWriteReal_2c8a3a2d5d1328049eb47e9ef6cc9282 )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("value") ) );
    
    }

    { //::cvWriteString
    
        typedef void ( *writeString_function_type )( ::cv::FileStorage &,char const *,char const *,int );
        
        bp::def( 
            "writeString"
            , writeString_function_type( &cvWriteString_72043510addf587750a274c07091202d )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("str"), bp::arg("quote")=(int)(0) ) );
    
    }

    { //::cv::drawContours
    
        typedef void ( *drawContours_function_type )( ::cv::Mat &,bp::tuple,int,::cv::Scalar const &,int,int,bp::tuple,int,::cv::Point );
        
        bp::def( 
            "drawContours"
            , drawContours_function_type( &drawContours_03a5aed7ca57b253d8b3346ee2f05f74 )
            , ( bp::arg("image"), bp::arg("contours"), bp::arg("contourIdx"), bp::arg("color"), bp::arg("thickness")=(int)(1), bp::arg("lineType")=(int)(8), bp::arg("hierarchy")=convert_vector_to_seq(std::vector<cv::Vec4i>()), bp::arg("maxLevel")=(int)(2147483647), bp::arg("offset")=cv::Point_<int>() ) );
    
    }

    { //::cv::ellipse2Poly
    
        typedef boost::python::object ( *ellipse2Poly_function_type )( ::cv::Point,::cv::Size,int,int,int,int,bp::tuple );
        
        bp::def( 
            "ellipse2Poly"
            , ellipse2Poly_function_type( &ellipse2Poly_a1937ebf152fa736fc27822db2e0081a )
            , ( bp::arg("center"), bp::arg("axes"), bp::arg("angle"), bp::arg("arcStart"), bp::arg("arcEnd"), bp::arg("delta"), bp::arg("pts") ) );
    
    }

    { //::cv::estimateAffine3D
    
        typedef boost::python::tuple ( *estimateAffine3D_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat &,bp::tuple,double,double );
        
        bp::def( 
            "estimateAffine3D"
            , estimateAffine3D_function_type( &estimateAffine3D_fd3dca5e5fd5d2ce4664db813a2c08bf )
            , ( bp::arg("from"), bp::arg("to"), bp::arg("out"), bp::arg("outliers"), bp::arg("param1")=3.0e+0, bp::arg("param2")=9.89999999999999991118215802998747676610946655273e-1 ) );
    
    }

    { //::cv::fillConvexPoly
    
        typedef void ( *fillConvexPoly_function_type )( ::cv::Mat &,boost::python::object,::cv::Scalar const &,int,int );
        
        bp::def( 
            "fillConvexPoly"
            , fillConvexPoly_function_type( &fillConvexPoly_1312287b0cded13c02c57cc3d8ebf4b4 )
            , ( bp::arg("img"), bp::arg("pts"), bp::arg("color"), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0) ) );
    
    }

    { //::cv::fillPoly
    
        typedef void ( *fillPoly_function_type )( ::cv::Mat &,boost::python::object,::cv::Scalar const &,int,int,::cv::Point );
        
        bp::def( 
            "fillPoly"
            , fillPoly_function_type( &fillPoly_e862cfcf1208f193efcd2bec59b744ec )
            , ( bp::arg("img"), bp::arg("pts"), bp::arg("color"), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0), bp::arg("offset")=cv::Point_<int>() ) );
    
    }

    { //::cv::findChessboardCorners
    
        typedef boost::python::tuple ( *findChessboardCorners_function_type )( ::cv::Mat const &,::cv::Size,int );
        
        bp::def( 
            "findChessboardCorners"
            , findChessboardCorners_function_type( &findChessboardCorners_dbf15a4ace0e613206118382aa1793ea )
            , ( bp::arg("image"), bp::arg("patternSize"), bp::arg("flags")=(int)(3) ) );
    
    }

    { //::cv::findContours
    
        typedef boost::python::tuple ( *findContours_function_type )( ::cv::Mat const &,int,int,::cv::Point );
        
        bp::def( 
            "findContours"
            , findContours_function_type( &findContours_68285032b2b0f15f13e30f19da8327fa )
            , ( bp::arg("image"), bp::arg("mode"), bp::arg("method"), bp::arg("offset")=cv::Point_<int>() ) );
    
    }

    { //::cv::findFundamentalMat
    
        typedef boost::python::tuple ( *findFundamentalMat2_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double,double );
        
        bp::def( 
            "findFundamentalMat2"
            , findFundamentalMat2_function_type( &findFundamentalMat_4b8947da99452ee36abb2b044e941f4a )
            , ( bp::arg("points1"), bp::arg("points2"), bp::arg("method")=int(::cv::FM_RANSAC), bp::arg("param1")=3.0e+0, bp::arg("param2")=9.89999999999999991118215802998747676610946655273e-1 ) );
    
    }

    { //::cv::findHomography
    
        typedef boost::python::tuple ( *findHomography2_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double );
        
        bp::def( 
            "findHomography2"
            , findHomography2_function_type( &findHomography_43999ba4bb258d7c74f144c8915f1665 )
            , ( bp::arg("srcPoints"), bp::arg("dstPoints"), bp::arg("method")=(int)(0), bp::arg("ransacReprojThreshold")=0 ) );
    
    }

    { //::cv::floodFill
    
        typedef boost::python::tuple ( *floodFill_function_type )( ::cv::Mat &,::cv::Mat &,::cv::Point,::cv::Scalar,::cv::Scalar,::cv::Scalar,int );
        
        bp::def( 
            "floodFill"
            , floodFill_function_type( &floodFill_a833ccdf7b45572779d5c63d9adc2b15 )
            , ( bp::arg("image"), bp::arg("mask"), bp::arg("seedPoint"), bp::arg("newVal"), bp::arg("loDiff")=cv::Scalar_<double>(), bp::arg("upDiff")=cv::Scalar_<double>(), bp::arg("flags")=(int)(4) ) );
    
    }

    { //::cv::floodFill
    
        typedef boost::python::tuple ( *floodFill_function_type )( ::cv::Mat &,::cv::Point,::cv::Scalar,::cv::Scalar,::cv::Scalar,int );
        
        bp::def( 
            "floodFill"
            , floodFill_function_type( &floodFill_75a8a8f3e3e22b4d281bb304a7881151 )
            , ( bp::arg("image"), bp::arg("seedPoint"), bp::arg("newVal"), bp::arg("loDiff")=cv::Scalar_<double>(), bp::arg("upDiff")=cv::Scalar_<double>(), bp::arg("flags")=(int)(4) ) );
    
    }

    { //::cv::getAffineTransform
    
        typedef boost::python::object ( *getAffineTransform_function_type )( boost::python::object,boost::python::object );
        
        bp::def( 
            "getAffineTransform"
            , getAffineTransform_function_type( &getAffineTransform_aa493630c3e4efe1ff49141fe5060922 )
            , ( bp::arg("src"), bp::arg("dst") ) );
    
    }

    { //::cv::getPerspectiveTransform
    
        typedef boost::python::object ( *getPerspectiveTransform_function_type )( boost::python::object,boost::python::object );
        
        bp::def( 
            "getPerspectiveTransform"
            , getPerspectiveTransform_function_type( &getPerspectiveTransform_c06a0392152cb20f6b57ae1ff2ac2c11 )
            , ( bp::arg("src"), bp::arg("dst") ) );
    
    }

    { //::cv::getTextSize
    
        typedef boost::python::tuple ( *getTextSize_function_type )( ::std::string const &,int,double,int );
        
        bp::def( 
            "getTextSize"
            , getTextSize_function_type( &getTextSize_efe6452b14ca0fcca5a50ca33199f5e7 )
            , ( bp::arg("text"), bp::arg("fontFace"), bp::arg("fontScale"), bp::arg("thickness") ) );
    
    }

    { //::cv::goodFeaturesToTrack
    
        typedef boost::python::object ( *goodFeaturesToTrack_function_type )( ::cv::Mat const &,int,double,double,::cv::Mat const &,int,bool,double );
        
        bp::def( 
            "goodFeaturesToTrack"
            , goodFeaturesToTrack_function_type( &goodFeaturesToTrack_a887e3eb7b667339b1ac0c1a02f5735c )
            , ( bp::arg("image"), bp::arg("maxCorners"), bp::arg("qualityLevel"), bp::arg("minDistance"), bp::arg("mask")=cv::Mat(), bp::arg("blockSize")=(int)(3), bp::arg("useHarrisDetector")=(bool)(false), bp::arg("k")=4.00000000000000008326672684688674053177237510681e-2 ) );
    
    }

    { //::cv::groupRectangles
    
        typedef boost::python::object ( *groupRectangles_function_type )( bp::tuple,int,double );
        
        bp::def( 
            "groupRectangles"
            , groupRectangles_function_type( &groupRectangles_daddb1eb144574c44042d3cef39f8656 )
            , ( bp::arg("rectList"), bp::arg("groupThreshold"), bp::arg("eps")=2.00000000000000011102230246251565404236316680908e-1 ) );
    
    }

    { //::cv::imencode
    
        typedef boost::python::tuple ( *imencode_function_type )( ::std::string const &,::cv::Mat const &,bp::tuple );
        
        bp::def( 
            "imencode"
            , imencode_function_type( &imencode_7058867f40db2ceceebdc74b4943c841 )
            , ( bp::arg("ext"), bp::arg("img"), bp::arg("params")=convert_vector_to_seq(std::vector<int>()) ) );
    
    }

    { //::cv::imwrite
    
        typedef boost::python::object ( *imwrite_function_type )( ::std::string const &,::cv::Mat const &,bp::tuple );
        
        bp::def( 
            "imwrite"
            , imwrite_function_type( &imwrite_08123c4d4c07e7af51577328378c9683 )
            , ( bp::arg("filename"), bp::arg("img"), bp::arg("params")=convert_vector_to_seq(std::vector<int>()) ) );
    
    }

    { //::cv::initCameraMatrix2D
    
        typedef boost::python::object ( *initCameraMatrix2D_function_type )( bp::tuple,bp::tuple,::cv::Size,double );
        
        bp::def( 
            "initCameraMatrix2D"
            , initCameraMatrix2D_function_type( &initCameraMatrix2D_a63e0813c9e7ddf60786347e47acca95 )
            , ( bp::arg("objectPoints"), bp::arg("imagePoints"), bp::arg("imageSize"), bp::arg("aspectRatio")=1.0e+0 ) );
    
    }

    { //::cv::kmeans
    
        typedef boost::python::tuple ( *kmeans_function_type )( ::cv::Mat const &,int,::cv::Mat &,::cv::TermCriteria,int,int );
        
        bp::def( 
            "kmeans"
            , kmeans_function_type( &kmeans_7acc1faebc4e430dbd210d93113e85c9 )
            , ( bp::arg("data"), bp::arg("K"), bp::arg("best_labels"), bp::arg("criteria"), bp::arg("attempts"), bp::arg("flags") ) );
    
    }

    { //::cv::merge
    
        typedef void ( *merge_function_type )( boost::python::object,::cv::MatND & );
        
        bp::def( 
            "merge"
            , merge_function_type( &merge_3b2d3618a31ce673ada132517e890dcb )
            , ( bp::arg("mvbegin"), bp::arg("dst") ) );
    
    }

    { //::cv::merge
    
        typedef void ( *merge_function_type )( boost::python::object,::cv::Mat & );
        
        bp::def( 
            "merge"
            , merge_function_type( &merge_a47eeb2aff422ee6c05b5574cb0848fe )
            , ( bp::arg("mv"), bp::arg("dst") ) );
    
    }

    { //::cv::polylines
    
        typedef void ( *polylines_function_type )( ::cv::Mat &,boost::python::object,bool,::cv::Scalar const &,int,int,int );
        
        bp::def( 
            "polylines"
            , polylines_function_type( &polylines_4b2b9aca4a0ee1864678eae6b982fcc0 )
            , ( bp::arg("img"), bp::arg("pts"), bp::arg("isClosed"), bp::arg("color"), bp::arg("thickness")=(int)(1), bp::arg("lineType")=(int)(8), bp::arg("shift")=(int)(0) ) );
    
    }

    { //::cv::projectPoints
    
        typedef boost::python::object ( *projectPoints2_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,double );
        
        bp::def( 
            "projectPoints2"
            , projectPoints2_function_type( &projectPoints_c3cbd5f3e0c4a976b617302062632da4 )
            , ( bp::arg("objectPoints"), bp::arg("rvec"), bp::arg("tvec"), bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("dpdrot"), bp::arg("dpdt"), bp::arg("dpdf"), bp::arg("dpdc"), bp::arg("dpddist"), bp::arg("aspectRatio")=0 ) );
    
    }

    { //::cv::projectPoints
    
        typedef boost::python::object ( *projectPoints_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const & );
        
        bp::def( 
            "projectPoints"
            , projectPoints_function_type( &projectPoints_ce9cea7b4fadb5986d2a47a4d012fac0 )
            , ( bp::arg("objectPoints"), bp::arg("rvec"), bp::arg("tvec"), bp::arg("cameraMatrix"), bp::arg("distCoeffs") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_KeyPoints_function_type )( ::cv::FileNode const & );
        
        bp::def( 
            "read_KeyPoints"
            , read_KeyPoints_function_type( &read_19f776a07d0494421b17575379bc2106 )
            , ( bp::arg("node") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_SparseMat_function_type )( ::cv::FileNode const &,::cv::SparseMat const & );
        
        bp::def( 
            "read_SparseMat"
            , read_SparseMat_function_type( &read_70c5e2668ef6bb953f654143837a7095 )
            , ( bp::arg("node"), bp::arg("default_mat")=cv::SparseMat() ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_MatND_function_type )( ::cv::FileNode const &,::cv::MatND const & );
        
        bp::def( 
            "read_MatND"
            , read_MatND_function_type( &read_fcf3602693271e7c8a4e15ff65aede4c )
            , ( bp::arg("node"), bp::arg("default_mat")=cv::MatND() ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_Mat_function_type )( ::cv::FileNode const &,::cv::Mat const & );
        
        bp::def( 
            "read_Mat"
            , read_Mat_function_type( &read_fd962997898e5b5f59cbef9efc942bcd )
            , ( bp::arg("node"), bp::arg("default_mat")=cv::Mat() ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_str_function_type )( ::cv::FileNode const &,::std::string const & );
        
        bp::def( 
            "read_str"
            , read_str_function_type( &read_31e582223a7f98972af6d67b7558569e )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_double_function_type )( ::cv::FileNode const &,double );
        
        bp::def( 
            "read_double"
            , read_double_function_type( &read_9a054275260bdb7b0741c9b9e8cf5aae )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_float_function_type )( ::cv::FileNode const &,float );
        
        bp::def( 
            "read_float"
            , read_float_function_type( &read_9b06f36c44aa0d63d7f9f36cebc8d25f )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_inst_function_type )( ::cv::FileNode const &,int );
        
        bp::def( 
            "read_inst"
            , read_inst_function_type( &read_29c2b389d482b9f6d13cfbe5d7264926 )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_short_function_type )( ::cv::FileNode const &,short int );
        
        bp::def( 
            "read_short"
            , read_short_function_type( &read_62eac78db6563e1e714f1e282bf790db )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_ushort_function_type )( ::cv::FileNode const &,::ushort );
        
        bp::def( 
            "read_ushort"
            , read_ushort_function_type( &read_81b0a1f4d595a311c77148001bd0046d )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_schar_function_type )( ::cv::FileNode const &,::schar );
        
        bp::def( 
            "read_schar"
            , read_schar_function_type( &read_b68923bb48bf8de904fed0f0570414f5 )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_uchar_function_type )( ::cv::FileNode const &,::uchar );
        
        bp::def( 
            "read_uchar"
            , read_uchar_function_type( &read_e3dbdb6033985682cd13b98ac06df84e )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::read
    
        typedef boost::python::object ( *read_bool_function_type )( ::cv::FileNode const &,bool );
        
        bp::def( 
            "read_bool"
            , read_bool_function_type( &read_2ba57a356ec17a70685f21fbad5a9438 )
            , ( bp::arg("node"), bp::arg("default_value") ) );
    
    }

    { //::cv::split
    
        typedef void ( *split_function_type )( ::cv::MatND const &,boost::python::object );
        
        bp::def( 
            "split"
            , split_function_type( &split_2e154aaf70f5c323ceec9f447e404d8a )
            , ( bp::arg("m"), bp::arg("mv") ) );
    
    }

    { //::cv::split
    
        typedef void ( *split_function_type )( ::cv::Mat const &,boost::python::object );
        
        bp::def( 
            "split"
            , split_function_type( &split_d88fca83dae3e7420e6688bbbcd2ac41 )
            , ( bp::arg("m"), bp::arg("mvbegin") ) );
    
    }

    { //::cv::stereoCalibrate
    
        typedef void ( *stereoCalibrate_function_type )( bp::tuple,bp::tuple,bp::tuple,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Size,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::Mat &,::cv::TermCriteria,int );
        
        bp::def( 
            "stereoCalibrate"
            , stereoCalibrate_function_type( &stereoCalibrate_14726b7172922289400130b4861f4a12 )
            , ( bp::arg("objectPoints"), bp::arg("imagePoints1"), bp::arg("imagePoints2"), bp::arg("cameraMatrix1"), bp::arg("distCoeffs1"), bp::arg("cameraMatrix2"), bp::arg("distCoeffs2"), bp::arg("imageSize"), bp::arg("R"), bp::arg("T"), bp::arg("E"), bp::arg("F"), bp::arg("criteria")=cv::TermCriteria(3, 30, 9.99999999999999954748111825886258685613938723691e-7), bp::arg("flags")=int(::cv::CALIB_FIX_INTRINSIC) ) );
    
    }

    { //::cv::undistortPoints
    
        typedef boost::python::object ( *undistortPoints2_function_type )( ::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const &,::cv::Mat const & );
        
        bp::def( 
            "undistortPoints2"
            , undistortPoints2_function_type( &undistortPoints_e5fdbe55500ffb118c2a9845da49f34b )
            , ( bp::arg("src"), bp::arg("cameraMatrix"), bp::arg("distCoeffs"), bp::arg("R")=cv::Mat(), bp::arg("P")=cv::Mat() ) );
    
    }

    { //::cv::write
    
        typedef void ( *write_function_type )( ::cv::FileStorage &,::std::string const &,bp::tuple );
        
        bp::def( 
            "write"
            , write_function_type( &write_df76e3ba45561ddd23c917a610929778 )
            , ( bp::arg("fs"), bp::arg("name"), bp::arg("keypoints") ) );
    
    }

    bp::to_python_converter<CvRNG, CvRNG_to_python, false>();

    bp::to_python_converter<CvRect, CvRect_to_python, false>();

    bp::to_python_converter<CvScalar, CvScalar_to_python, false>();

    bp::to_python_converter<CvPoint, CvPoint_to_python, false>();

    bp::to_python_converter<CvPoint2D32f, CvPoint2D32f_to_python, false>();

    bp::to_python_converter<CvPoint3D32f, CvPoint3D32f_to_python, false>();

    bp::to_python_converter<CvSize, CvSize_to_python, false>();

    bp::to_python_converter<CvBox2D, CvBox2D_to_python, false>();

    bp::to_python_converter<CvTermCriteria, CvTermCriteria_to_python, false>();

    bp::to_python_converter<CvSlice, CvSlice_to_python, false>();

    bp::to_python_converter<CvMatND, CvMatND_to_python, false>();

    bp::def("mixChannels", &bp::mixChannels, ( bp::arg("src"), bp::arg("dst"), bp::arg("fromTo") ));

    bp::def("minMaxLoc", &bp::minMaxLoc, ( bp::arg("a"), bp::arg("mask")=bp::object() ));

    bp::def( 
        "calcHist"
        , (void (*)( bp::tuple const &, bp::tuple const &, ::cv::Mat const &, 
            bp::object &, int, bp::tuple const &, bp::tuple const &, bool, 
            bool ))( &sd_calcHist )
        , ( bp::arg("images"), bp::arg("channels"), bp::arg("mask"), 
            bp::arg("hist"), bp::arg("dims"), bp::arg("histSize"), 
            bp::arg("ranges"), bp::arg("uniform")=bp::object(true), 
            bp::arg("accumulate")=bp::object(false) ) );

    bp::def( 
        "calcBackProject"
        , (void (*)( bp::tuple const &, bp::tuple const &, 
            bp::object &, cv::Mat const &, bp::tuple const &, double, 
            bool ))( &sd_calcBackProject )
        , ( bp::arg("images"), bp::arg("channels"), 
            bp::arg("hist"), bp::arg("backProject"), 
            bp::arg("ranges"), bp::arg("scale")=bp::object(1.0), 
            bp::arg("uniform")=bp::object(true) ) );

    bp::def( 
        "approxPolyDP"
        , (bp::object (*)( cv::Mat const &, double, bool ))( &sd_approxPolyDP )
        , ( bp::arg("curve"), bp::arg("epsilon"), bp::arg("closed") ) );

    bp::def( 
        "convexHull"
        , (bp::object (*)( cv::Mat const &, bool ))( &sd_convexHull )
        , ( bp::arg("points"), bp::arg("clockwise")=bp::object(false) ) );

    bp::def("drawChessboardCorners", &::drawChessboardCorners, (bp::arg("image"), bp::arg("patternSize"), bp::arg("corners"), bp::arg("patternWasFound")));

    register_global_variables();

    register_free_functions();
}

