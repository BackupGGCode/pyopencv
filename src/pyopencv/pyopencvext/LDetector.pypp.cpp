// This file has been generated by Py++.

#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "opencv_converters.hpp"
#include "__ctypes_integration.pypp.hpp"
#include "opencv_headers.hpp"
#include "LDetector.pypp.hpp"

namespace bp = boost::python;

static boost::python::object getMostStable2D_b5c618f0990cbbe4d2707bd2d9eb711d( ::cv::LDetector const & inst, ::cv::Mat const & image, bp::sequence keypoints, int maxCount, ::cv::PatchGenerator const & patchGenerator ){
    std::vector<cv::KeyPoint, std::allocator<cv::KeyPoint> > keypoints2;
    convert_seq_to_vector(keypoints, keypoints2);
    inst.getMostStable2D(image, keypoints2, maxCount, patchGenerator);
    keypoints = convert_vector_to_seq(keypoints2);
    return bp::object( keypoints );
}

static bp::sequence LDetector_call1( ::cv::LDetector const & inst, bp::object const & image_or_pyr, int maxCount=0, bool scaleCoords=true ){
    std::vector< cv::KeyPoint > keypoints;
    bp::extract<const cv::Mat &> image(image_or_pyr);
    if(image.check()) inst(image(), keypoints, maxCount, scaleCoords);
    else {
        std::vector< cv::Mat > pyr;
        convert_seq_to_vector(image_or_pyr, pyr);
        inst(pyr, keypoints, maxCount, scaleCoords);
    }
    return convert_vector_to_seq(keypoints);
}

void register_LDetector_class(){

    bp::class_< cv::LDetector >( "LDetector", bp::init< >() )    
        .add_property( "this", pyplus_conv::make_addressof_inst_getter< cv::LDetector >() )    
        .def( bp::init< int, int, int, int, double, double >(( bp::arg("_radius"), bp::arg("_threshold"), bp::arg("_nOctaves"), bp::arg("_nViews"), bp::arg("_baseFeatureSize"), bp::arg("_clusteringDistance") )) )    
        .def( 
            "getMostStable2D"
            , (boost::python::object (*)( ::cv::LDetector const &,::cv::Mat const &,bp::sequence,int,::cv::PatchGenerator const & ))( &getMostStable2D_b5c618f0990cbbe4d2707bd2d9eb711d )
            , ( bp::arg("inst"), bp::arg("image"), bp::arg("keypoints"), bp::arg("maxCount"), bp::arg("patchGenerator") ) )    
        .def( 
            "read"
            , (void ( ::cv::LDetector::* )( ::cv::FileNode const & ) )( &::cv::LDetector::read )
            , ( bp::arg("node") ) )    
        .def( 
            "setVerbose"
            , (void ( ::cv::LDetector::* )( bool ) )( &::cv::LDetector::setVerbose )
            , ( bp::arg("verbose") ) )    
        .def( 
            "write"
            , (void ( ::cv::LDetector::* )( ::cv::FileStorage &,::cv::String const & ) const)( &::cv::LDetector::write )
            , ( bp::arg("fs"), bp::arg("name")=std::string() ) )    
        .def_readwrite( "baseFeatureSize", &cv::LDetector::baseFeatureSize )    
        .def_readwrite( "clusteringDistance", &cv::LDetector::clusteringDistance )    
        .def_readwrite( "nOctaves", &cv::LDetector::nOctaves )    
        .def_readwrite( "nViews", &cv::LDetector::nViews )    
        .def_readwrite( "radius", &cv::LDetector::radius )    
        .def_readwrite( "threshold", &cv::LDetector::threshold )    
        .def_readwrite( "verbose", &cv::LDetector::verbose )    
        .def("__call__", &LDetector_call1, (bp::arg("image_or_pyr"), bp::arg("maxCount")=0, bp::arg("scaleCoords")=true));

}
