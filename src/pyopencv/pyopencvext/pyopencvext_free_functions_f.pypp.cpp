// This file has been generated by Py++.

#include "boost/python.hpp"
#include "opencv_headers.hpp"
#include "pyopencvext_free_functions_f.pypp.hpp"

namespace bp = boost::python;

void register_free_functions_f(){

    { //::cvFindNextContour
    
        typedef ::CvSeq * ( *findNextContour_function_type )( ::CvContourScanner );
        
        bp::def( 
            "findNextContour"
            , findNextContour_function_type( &::cvFindNextContour )
            , ( bp::arg("scanner") )
            , bp::with_custodian_and_ward_postcall< 0, 1, bp::return_value_policy< bp::reference_existing_object > >()
            , "\nWrapped function:"
    "\n    cvFindNextContour" );
    
    }

    { //::cvFindType
    
        typedef ::CvTypeInfo * ( *findType_function_type )( char const * );
        
        bp::def( 
            "findType"
            , findType_function_type( &::cvFindType )
            , ( bp::arg("type_name") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvFindType" );
    
    }

    { //::cvFirstType
    
        typedef ::CvTypeInfo * ( *firstType_function_type )(  );
        
        bp::def( 
            "firstType"
            , firstType_function_type( &::cvFirstType )
            , bp::return_value_policy< bp::reference_existing_object >()
            , "\nWrapped function:"
    "\n    cvFirstType" );
    
    }

    { //::cvFloor
    
        typedef int ( *floor_function_type )( double );
        
        bp::def( 
            "floor"
            , floor_function_type( &::cvFloor )
            , ( bp::arg("value") )
            , "\nWrapped function:"
    "\n    cvFloor" );
    
    }

    { //::cv::fastAtan2
    
        typedef float ( *fastAtan2_function_type )( float,float );
        
        bp::def( 
            "fastAtan2"
            , fastAtan2_function_type( &::cv::fastAtan2 )
            , ( bp::arg("y"), bp::arg("x") )
            , "\nCalculates the angle of a 2D vector in degrees."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-fastatan2" );
    
    }

    { //::cv::filter2D
    
        typedef void ( *filter2D_function_type )( ::cv::Mat const &,::cv::Mat &,int,::cv::Mat const &,::cv::Point,double,int );
        
        bp::def( 
            "filter2D"
            , filter2D_function_type( &::cv::filter2D )
            , ( bp::arg("src"), bp::arg("dst"), bp::arg("ddepth"), bp::arg("kernel"), bp::arg("anchor")=cv::Point_<int>(-0x000000001, -0x000000001), bp::arg("delta")=0, bp::arg("borderType")=int(::cv::BORDER_REFLECT_101) ) );
    
    }

    { //::cv::filterSpeckles
    
        typedef void ( *filterSpeckles_function_type )( ::cv::Mat &,double,int,double,::cv::Mat & );
        
        bp::def( 
            "filterSpeckles"
            , filterSpeckles_function_type( &::cv::filterSpeckles )
            , ( bp::arg("img"), bp::arg("newVal"), bp::arg("maxSpeckleSize"), bp::arg("maxDiff"), bp::arg("buf") ) );
    
    }

    { //::cv::findFundamentalMat
    
        typedef ::cv::Mat ( *findFundamentalMat_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double,double );
        
        bp::def( 
            "findFundamentalMat"
            , findFundamentalMat_function_type( &::cv::findFundamentalMat )
            , ( bp::arg("points1"), bp::arg("points2"), bp::arg("method")=int(::cv::FM_RANSAC), bp::arg("param1")=3.0e+0, bp::arg("param2")=9.89999999999999991118215802998747676610946655273e-1 ) );
    
    }

    { //::cv::findHomography
    
        typedef ::cv::Mat ( *findHomography_function_type )( ::cv::Mat const &,::cv::Mat const &,int,double );
        
        bp::def( 
            "findHomography"
            , findHomography_function_type( &::cv::findHomography )
            , ( bp::arg("srcPoints"), bp::arg("dstPoints"), bp::arg("method")=(int)(0), bp::arg("ransacReprojThreshold")=0 ) );
    
    }

    { //::cv::fitEllipse
    
        typedef ::cv::RotatedRect ( *fitEllipse_function_type )( ::cv::Mat const & );
        
        bp::def( 
            "fitEllipse"
            , fitEllipse_function_type( &::cv::fitEllipse )
            , ( bp::arg("points") ) );
    
    }

    { //::cv::fitLine
    
        typedef void ( *fitLine_function_type )( ::cv::Mat const &,::cv::Vec6f &,int,double,double,double );
        
        bp::def( 
            "fitLine"
            , fitLine_function_type( &::cv::fitLine )
            , ( bp::arg("points"), bp::arg("line"), bp::arg("distType"), bp::arg("param"), bp::arg("reps"), bp::arg("aeps") ) );
    
    }

    { //::cv::fitLine
    
        typedef void ( *fitLine_function_type )( ::cv::Mat const &,::cv::Vec4f &,int,double,double,double );
        
        bp::def( 
            "fitLine"
            , fitLine_function_type( &::cv::fitLine )
            , ( bp::arg("points"), bp::arg("line"), bp::arg("distType"), bp::arg("param"), bp::arg("reps"), bp::arg("aeps") ) );
    
    }

    { //::cv::flip
    
        typedef void ( *flip_function_type )( ::cv::Mat const &,::cv::Mat &,int );
        
        bp::def( 
            "flip"
            , flip_function_type( &::cv::flip )
            , ( bp::arg("a"), bp::arg("b"), bp::arg("flipCode") )
            , "\nFlips a 2D array around vertical, horizontal or both axes."
    "\nReference:"
    "\n    http://opencv.willowgarage.com/documentation/cpp/operations_on_arrays.html#cv-flip" );
    
    }

    { //::cv::fromUtf16
    
        typedef ::std::string ( *fromUtf16_function_type )( ::cv::WString const & );
        
        bp::def( 
            "fromUtf16"
            , fromUtf16_function_type( &::cv::fromUtf16 )
            , ( bp::arg("str") ) );
    
    }

}
